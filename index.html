<!DOCTYPE html>
<html lang="ko" data-theme="pink">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Íπ°ÌÜµ Ïù¥ÎØ∏ÏßÄ Ìé∏ÏßëÍ∏∞</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --transition: 0.3s ease; }

        [data-theme="pink"] {
            --bg: #fff5f7; --card: #ffffff; --border: #ffccd9;
            --text: #3d3035; --text-secondary: #6d5f64;
            --accent: #ff6b96; --accent-soft: #ffb3c6; --accent-bg: #fff0f3;
            --button-text: #ffffff; --shadow: rgba(255, 107, 150, 0.2);
            --input-bg: #fff8fa; --badge-bg: #ff6b96;
            --select-bg: rgba(255, 107, 150, 0.12); --select-border: #ff6b96;
        }
        [data-theme="blue"] {
            --bg: #f5f9ff; --card: #ffffff; --border: #c5daff;
            --text: #2a3542; --text-secondary: #5a6a7a;
            --accent: #4a8cff; --accent-soft: #a3c7ff; --accent-bg: #f0f6ff;
            --button-text: #ffffff; --shadow: rgba(74, 140, 255, 0.2);
            --input-bg: #f8fbff; --badge-bg: #4a8cff;
            --select-bg: rgba(74, 140, 255, 0.12); --select-border: #4a8cff;
        }
        [data-theme="dark"] {
            --bg: #0f0f14; --card: #1a1a22; --border: #3a3a48;
            --text: #f0f0f5; --text-secondary: #a0a0b0;
            --accent: #b49cff; --accent-soft: #8b7acc; --accent-bg: #28283a;
            --button-text: #ffffff; --shadow: rgba(0, 0, 0, 0.4);
            --input-bg: #22222c; --badge-bg: #b49cff;
            --select-bg: rgba(180, 156, 255, 0.15); --select-border: #b49cff;
        }

        body { font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); min-height: 100vh; padding: 32px 20px; transition: background var(--transition); }
        .wrapper { max-width: 1500px; margin: 0 auto; }
        .theme-switcher { display: flex; justify-content: center; gap: 12px; margin-bottom: 28px; }
        .theme-btn { width: 40px; height: 40px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; transition: all 0.2s ease; }
        .theme-btn:hover { transform: scale(1.1); }
        .theme-btn.active { border-color: var(--text); transform: scale(1.1); box-shadow: 0 4px 12px var(--shadow); }
        .theme-btn.pink { background: linear-gradient(135deg, #ffb3c6, #ff6b96); }
        .theme-btn.blue { background: linear-gradient(135deg, #a3c7ff, #4a8cff); }
        .theme-btn.dark { background: linear-gradient(135deg, #4a4a5a, #1a1a22); }
        .main-layout { display: grid; grid-template-columns: 380px 1fr; gap: 28px; align-items: start; }
        @media (max-width: 1100px) { .main-layout { grid-template-columns: 1fr; } }
        .card { background: var(--card); border: 1px solid var(--border); border-radius: 24px; padding: 32px 28px; box-shadow: 0 8px 32px var(--shadow); transition: all var(--transition); }
        .settings-panel .card { position: sticky; top: 20px; }
        .header { text-align: center; margin-bottom: 28px; }
        .logo { font-size: 42px; margin-bottom: 8px; }
        h1 { font-size: 24px; font-weight: 800; color: var(--text); margin-bottom: 6px; }
        .subtitle { font-size: 14px; color: var(--text-secondary); font-weight: 500; }
        .upload-area { border: 2px dashed var(--border); border-radius: 16px; padding: 36px 20px; text-align: center; cursor: pointer; transition: all 0.2s ease; margin-bottom: 20px; background: var(--input-bg); }
        .upload-area:hover { border-color: var(--accent); background: var(--accent-bg); }
        .upload-area.dragover { border-color: var(--accent); background: var(--accent-bg); transform: scale(1.02); }
        .upload-icon { font-size: 44px; margin-bottom: 12px; }
        .upload-text { color: var(--text-secondary); font-size: 15px; font-weight: 600; line-height: 1.6; }
        .upload-text span { color: var(--accent); font-weight: 700; }
        #fileInput { display: none; }
        .section-title { font-size: 14px; font-weight: 700; color: var(--accent); margin-bottom: 12px; text-transform: uppercase; }
        .filename-section, .format-section, .quality-section { display: none; margin-bottom: 20px; }
        .filename-section.active, .format-section.active, .quality-section.active { display: block; }
        .filename-input { width: 100%; padding: 14px 16px; border: 2px solid var(--border); border-radius: 12px; font-size: 15px; font-weight: 600; background: var(--input-bg); color: var(--text); transition: all 0.2s; font-family: inherit; }
        .filename-input:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 4px var(--shadow); }
        .format-options { display: flex; gap: 10px; flex-wrap: wrap; }
        .format-btn { flex: 1; min-width: 70px; padding: 12px; border: 2px solid var(--border); border-radius: 10px; background: var(--input-bg); cursor: pointer; transition: all 0.2s; text-align: center; }
        .format-btn:hover { border-color: var(--accent-soft); }
        .format-btn.active { border-color: var(--accent); background: var(--accent-bg); }
        .format-btn input { display: none; }
        .format-btn span { font-size: 14px; font-weight: 700; color: var(--text); }
        .format-btn.active span { color: var(--accent); }
        .quality-section { margin-top: 16px; }
        .quality-row { display: flex; align-items: center; gap: 12px; }
        .quality-slider { flex: 1; -webkit-appearance: none; height: 8px; background: var(--border); border-radius: 4px; outline: none; }
        .quality-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 22px; height: 22px; background: var(--accent); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 8px var(--shadow); }
        .quality-input { width: 60px; padding: 8px 10px; background: var(--input-bg); border: 2px solid var(--border); border-radius: 8px; font-size: 15px; font-weight: 700; font-family: inherit; color: var(--accent); text-align: center; }
        .quality-input:focus { outline: none; border-color: var(--accent); }
        .quality-input::-webkit-inner-spin-button, .quality-input::-webkit-outer-spin-button { -webkit-appearance: none; }
        .quality-percent { font-size: 15px; font-weight: 700; color: var(--text-secondary); }
        .format-hint { display: flex; align-items: center; gap: 6px; margin-top: 10px; padding: 8px 12px; background: rgba(100, 180, 255, 0.1); border: 1px solid rgba(100, 180, 255, 0.3); border-radius: 8px; font-size: 12px; }
        .hint-icon { font-size: 14px; }
        .hint-text { color: var(--text-secondary); font-weight: 500; }
        .quality-warning { margin-top: 10px; padding: 8px 12px; background: rgba(255, 180, 100, 0.15); border: 1px solid rgba(255, 150, 50, 0.3); border-radius: 8px; font-size: 12px; color: #cc8800; font-weight: 600; display: none; }
        .quality-warning.active { display: block; }
        .process-btn { width: 100%; padding: 16px; border: none; border-radius: 14px; font-size: 16px; font-weight: 700; font-family: inherit; cursor: pointer; transition: all 0.2s ease; display: none; background: var(--accent); color: var(--button-text); margin-top: 12px; }
        .process-btn.active { display: block; }
        .process-btn:hover:not(:disabled) { filter: brightness(1.08); transform: translateY(-2px); box-shadow: 0 6px 20px var(--shadow); }
        .process-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .toggle-section { margin-top: 16px; display: none; }
        .toggle-section.active { display: block; }
        .toggle-switch { display: flex; align-items: center; gap: 12px; cursor: pointer; user-select: none; padding: 10px 14px; background: var(--input-bg); border-radius: 10px; border: 1px solid var(--border); }
        .toggle-switch input { display: none; }
        .toggle-slider { width: 48px; height: 26px; background: var(--border); border-radius: 13px; position: relative; transition: all 0.2s; }
        .toggle-slider::after { content: ''; position: absolute; width: 20px; height: 20px; background: white; border-radius: 50%; top: 3px; left: 3px; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .toggle-switch input:checked + .toggle-slider { background: var(--accent); }
        .toggle-switch input:checked + .toggle-slider::after { left: 25px; }
        .toggle-label { font-size: 14px; font-weight: 700; color: var(--text-secondary); }
        .toggle-switch input:checked ~ .toggle-label { color: var(--accent); }
        .modal-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 2000; backdrop-filter: blur(4px); }
        .modal-overlay.active { display: flex; }
        .modal { background: var(--card); border: 1px solid var(--border); border-radius: 20px; padding: 32px; max-width: 360px; width: 90%; text-align: center; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); animation: modalIn 0.2s ease; }
        @keyframes modalIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .modal-icon { font-size: 48px; margin-bottom: 16px; }
        .modal-title { font-size: 20px; font-weight: 700; color: var(--text); margin-bottom: 8px; }
        .modal-desc { font-size: 15px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.5; }
        .modal-buttons { display: flex; gap: 12px; }
        .modal-btn { flex: 1; padding: 14px; border: none; border-radius: 12px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-family: inherit; }
        .modal-btn.cancel { background: var(--input-bg); color: var(--text-secondary); border: 2px solid var(--border); }
        .modal-btn.cancel:hover { border-color: var(--accent); color: var(--accent); }
        .modal-btn.confirm { background: #ff5c5c; color: white; }
        .modal-btn.confirm:hover { background: #ff4040; }
        .status { margin-top: 16px; padding: 14px; border-radius: 12px; text-align: center; font-size: 15px; font-weight: 600; display: none; }
        .status.success { display: block; background: rgba(0, 200, 140, 0.15); color: #00b080; border: 1px solid rgba(0, 200, 140, 0.3); }
        .status.error { display: block; background: rgba(255, 90, 90, 0.15); color: #ff5050; border: 1px solid rgba(255, 90, 90, 0.3); }
        .preview-panel { display: none; }
        .preview-panel.active { display: block; }
        .preview-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .preview-title { font-size: 18px; font-weight: 700; color: var(--text); }
        .preview-actions-row { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding: 10px 14px; background: var(--input-bg); border-radius: 12px; border: 1px solid var(--border); flex-wrap: wrap; }
        .action-label { font-size: 13px; font-weight: 700; color: var(--text-secondary); }
        .action-divider { width: 1px; height: 24px; background: var(--border); margin: 0 8px; }
        .action-btn { background: var(--card); border: 2px solid var(--border); color: var(--text-secondary); font-size: 13px; font-weight: 600; cursor: pointer; padding: 6px 12px; border-radius: 8px; transition: all 0.2s; }
        .action-btn:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
        .action-btn.danger:hover:not(:disabled) { border-color: #ff5c5c; color: #ff5c5c; background: rgba(255, 92, 92, 0.1); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .file-count-badge { font-size: 13px; color: var(--button-text); background: var(--badge-bg); padding: 4px 12px; border-radius: 16px; font-weight: 700; min-width: 40px; text-align: center; }
        .file-count-badge.secondary { background: var(--accent-soft); }
        .help-text { font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; padding: 12px 14px; background: var(--input-bg); border-radius: 10px; border: 1px solid var(--border); font-weight: 500; }
        .help-text span { color: var(--accent); font-weight: 700; }
        .image-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 24px; max-height: calc(100vh - 280px); overflow-y: auto; padding: 32px 60px; background: var(--input-bg); border-radius: 12px; min-height: 200px; }
        @media (max-width: 1200px) { .image-grid { grid-template-columns: repeat(3, 1fr); padding: 28px 40px; } }
        @media (max-width: 900px) { .image-grid { grid-template-columns: repeat(2, 1fr); padding: 24px 32px; } }
        .image-item { position: relative; border-radius: 14px; overflow: hidden; background: var(--card); border: 3px solid var(--border); transition: all 0.15s ease; cursor: pointer; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        .image-item:hover { border-color: var(--accent-soft); }
        .image-item.selected { border-color: var(--select-border); background: var(--select-bg); box-shadow: 0 0 0 3px var(--select-bg); }
        .image-item.long-press-active { transform: scale(0.95); opacity: 0.8; }
        .image-item.dragging { opacity: 0.4; }
        .image-item.drop-before::before { content: ''; position: absolute; left: -14px; top: 0; bottom: 0; width: 6px; background: var(--accent); border-radius: 3px; z-index: 10; }
        .image-item.drop-after::after { content: ''; position: absolute; right: -14px; top: 0; bottom: 0; width: 6px; background: var(--accent); border-radius: 3px; z-index: 10; }
        .image-thumb { width: 100%; aspect-ratio: 1; object-fit: cover; display: block; pointer-events: none; }
        .image-order { position: absolute; top: 10px; left: 10px; background: var(--badge-bg); color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 700; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .image-checkbox { position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; background: rgba(255,255,255,0.9); border: 2px solid var(--border); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 14px; color: transparent; pointer-events: none; }
        .image-item.selected .image-checkbox { background: var(--accent); border-color: var(--accent); color: white; }
        .image-info { padding: 12px 14px; }
        .image-name { font-size: 14px; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
        .image-size { font-size: 13px; color: var(--text-secondary); font-weight: 500; }
        .image-output { font-size: 13px; color: var(--accent); font-weight: 600; margin-top: 6px; padding-top: 6px; border-top: 1px dashed var(--border); }
        .empty-state { grid-column: 1 / -1; text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        .empty-icon { font-size: 56px; margin-bottom: 16px; opacity: 0.6; }
        .empty-text { font-size: 16px; font-weight: 500; line-height: 1.6; }
        .image-grid::-webkit-scrollbar { width: 8px; }
        .image-grid::-webkit-scrollbar-track { background: var(--input-bg); border-radius: 4px; }
        .image-grid::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: var(--card); border: 2px solid var(--accent); color: var(--text); padding: 12px 24px; border-radius: 12px; font-size: 14px; font-weight: 600; box-shadow: 0 8px 32px var(--shadow); z-index: 1500; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .toast.active { opacity: 1; }
        @media (max-width: 600px) { .main-layout { gap: 20px; } .card { padding: 24px 20px; } h1 { font-size: 22px; } }

        /* ÏóêÎîîÌÑ∞ Ïä§ÌÉÄÏùº */
        .editor-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; z-index: 3000; backdrop-filter: blur(8px); }
        .editor-overlay.active { display: flex; }
        body.editor-open { overflow: hidden; position: fixed; width: 100%; height: 100%; }
        .editor-container { background: var(--card); border-radius: 20px; max-width: 95vw; max-height: 95vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); animation: modalIn 0.2s ease; overflow: hidden; }
        .editor-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
        .editor-title { font-size: 18px; font-weight: 700; color: var(--text); }
        .editor-header-btns { display: flex; align-items: center; gap: 8px; }
        .editor-nav-btn { width: 36px; height: 36px; border-radius: 8px; background: var(--input-bg); border: 2px solid var(--border); cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; color: var(--text-secondary); transition: all 0.2s; font-weight: 700; }
        .editor-nav-btn:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
        .editor-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .editor-close { width: 36px; height: 36px; border-radius: 50%; background: var(--input-bg); border: 2px solid var(--border); cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center; color: var(--text-secondary); transition: all 0.2s; }
        .editor-close:hover { border-color: var(--accent); color: var(--accent); }
        .editor-body { display: flex; flex: 1; overflow: hidden; }
        .editor-toolbar { width: 180px; background: var(--input-bg); border-right: 1px solid var(--border); padding: 16px; display: flex; flex-direction: column; gap: 16px; }
        .tool-section { display: flex; flex-direction: column; gap: 8px; }
        .tool-section-title { font-size: 11px; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; }
        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .tool-btn { aspect-ratio: 1; border-radius: 10px; background: var(--card); border: 2px solid var(--border); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.15s; color: var(--text); }
        .tool-btn:hover { border-color: var(--accent-soft); }
        .tool-btn.active { border-color: var(--accent); background: var(--accent-bg); }
        .tool-divider { height: 1px; background: var(--border); margin: 4px 0; }
        .option-group { display: flex; flex-direction: column; gap: 12px; }
        .option-row { display: flex; align-items: center; gap: 8px; }
        .option-label { font-size: 12px; font-weight: 600; color: var(--text-secondary); min-width: 36px; }
        .option-slider { flex: 1; -webkit-appearance: none; height: 6px; background: var(--border); border-radius: 3px; }
        .option-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; }
        .option-input { width: 50px; padding: 6px 8px; background: var(--input-bg); border: 2px solid var(--border); border-radius: 6px; font-size: 13px; font-weight: 700; font-family: inherit; color: var(--accent); text-align: center; }
        .option-input:focus { outline: none; border-color: var(--accent); }
        .color-row { display: flex; align-items: center; gap: 8px; }
        .color-picker { flex: 1; height: 32px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; padding: 2px; }
        .editor-canvas-area { flex: 1; display: flex; align-items: center; justify-content: center; padding: 20px; background: var(--bg); min-width: 500px; min-height: 400px; position: relative; }
        .editor-canvas { max-width: 100%; max-height: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); cursor: crosshair; touch-action: none; }
        .img-nav-btn { position: absolute; top: 50%; transform: translateY(-50%); width: 48px; height: 48px; border-radius: 50%; background: var(--card); border: 2px solid var(--border); cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center; color: var(--text); transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10; }
        .img-nav-btn:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); transform: translateY(-50%) scale(1.1); }
        .img-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .img-nav-btn.prev { left: 10px; }
        .img-nav-btn.next { right: 10px; }
        .brush-cursor { position: fixed; border: 2px solid var(--accent); border-radius: 50%; pointer-events: none; z-index: 9999; display: none; transform: translate(-50%, -50%); background: rgba(255, 107, 150, 0.15); }
        .brush-cursor.active { display: block; }
        .brush-cursor.mosaic { border-style: dashed; background: rgba(128, 128, 128, 0.2); border-color: #666; }
        .brush-cursor.eraser { border-style: dotted; background: rgba(255, 255, 255, 0.3); border-color: #00aa00; }
        .save-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 4000; backdrop-filter: blur(4px); }
        .save-modal.active { display: flex; }
        .save-modal-content { background: var(--card); border-radius: 16px; padding: 28px; max-width: 380px; width: 90%; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: modalIn 0.2s ease; }
        .save-modal-icon { font-size: 48px; margin-bottom: 16px; }
        .save-modal-title { font-size: 18px; font-weight: 700; color: var(--text); margin-bottom: 8px; }
        .save-modal-desc { font-size: 14px; color: var(--text-secondary); margin-bottom: 24px; }
        .save-modal-buttons { display: flex; gap: 10px; }
        .save-modal-btn { flex: 1; padding: 12px 16px; border-radius: 10px; font-size: 14px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-family: inherit; border: none; }
        .save-modal-btn.discard { background: var(--input-bg); color: #ff5c5c; border: 2px solid #ff5c5c; }
        .save-modal-btn.cancel { background: var(--input-bg); color: var(--text-secondary); border: 2px solid var(--border); }
        .save-modal-btn.save { background: var(--accent); color: white; border: 2px solid var(--accent); }
        .editor-footer { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-top: 1px solid var(--border); }
        .editor-shortcut { font-size: 12px; color: var(--text-secondary); }
        .editor-shortcut kbd { background: var(--input-bg); border: 1px solid var(--border); padding: 2px 6px; border-radius: 4px; font-family: inherit; font-weight: 600; }
        .editor-buttons { display: flex; gap: 12px; }
        .editor-btn { padding: 12px 24px; border-radius: 10px; font-size: 14px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-family: inherit; }
        .editor-btn.secondary { background: var(--input-bg); border: 2px solid var(--border); color: var(--text-secondary); }
        .editor-btn.secondary:hover { border-color: var(--accent); color: var(--accent); }
        .editor-btn.primary { background: var(--accent); border: none; color: white; }
        .editor-btn.primary:hover { filter: brightness(1.1); }

        @media (max-width: 768px) {
            .editor-container { max-width: 100vw; max-height: 100vh; width: 100vw; height: 100vh; border-radius: 0; }
            .editor-body { flex-direction: column; }
            .editor-toolbar { width: 100%; flex-direction: row; flex-wrap: wrap; padding: 12px; gap: 12px; border-right: none; border-bottom: 1px solid var(--border); overflow-x: auto; }
            .tool-section { flex-direction: row; align-items: center; gap: 8px; }
            .tool-section-title { display: none; }
            .tool-grid { display: flex; gap: 6px; }
            .tool-btn { width: 40px; height: 40px; }
            .tool-divider { width: 1px; height: 30px; margin: 0 4px; }
            .option-group { flex-direction: row; align-items: center; gap: 8px; }
            .option-row { flex: 1; min-width: 120px; }
            .editor-canvas-area { min-width: unset; min-height: 200px; padding: 10px; }
            .img-nav-btn { width: 36px; height: 36px; font-size: 16px; }
            .img-nav-btn.prev { left: 5px; }
            .img-nav-btn.next { right: 5px; }
            .editor-footer { flex-direction: column; gap: 12px; padding: 12px 16px; }
            .editor-shortcut { font-size: 10px; text-align: center; }
            .editor-buttons { width: 100%; }
            .editor-btn { flex: 1; padding: 14px 16px; }
        }
    </style>
</head>
<body>
    <div class="wrapper">
        <div class="theme-switcher">
            <button class="theme-btn pink active" data-theme="pink" title="ÌïëÌÅ¨"></button>
            <button class="theme-btn blue" data-theme="blue" title="Î∏îÎ£®"></button>
            <button class="theme-btn dark" data-theme="dark" title="Îã§ÌÅ¨"></button>
        </div>
        <div class="main-layout">
            <div class="settings-panel">
                <div class="card">
                    <div class="header">
                        <div class="logo">üßπ</div>
                        <h1>Íπ°ÌÜµ Ïù¥ÎØ∏ÏßÄ Ìé∏ÏßëÍ∏∞</h1>
                        <p class="subtitle">Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ & ÏùºÍ¥Ñ Î≥ÄÌôò & Ïù¥Î¶Ñ Î≥ÄÍ≤Ω & Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë</p>
                    </div>
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">üìÅ</div>
                        <div class="upload-text"><span>ÌÅ¥Î¶≠</span> ÎòêÎäî <span>ÎìúÎûòÍ∑∏</span>Î°ú ÏóÖÎ°úÎìú<br>PNG, JPG, WebP, GIF</div>
                    </div>
                    <input type="file" id="fileInput" accept="image/png,image/jpeg,image/webp,image/gif" multiple>
                    <div class="filename-section" id="filenameSection">
                        <div class="section-title">üìù Ï∂úÎ†• ÌååÏùºÎ™Ö</div>
                        <input type="text" class="filename-input" id="baseFilename" placeholder="1, 2, 3... (ÎπÑÏö∞Î©¥ Ïà´ÏûêÎ°ú Ï†ÄÏû•)">
                    </div>
                    <div class="toggle-section">
                        <div class="section-title">üßπ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞</div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="removeMetadata" checked>
                            <span class="toggle-slider"></span>
                            <span class="toggle-label" id="metadataLabel">ON</span>
                        </label>
                    </div>
                    <div class="format-section" id="formatSection">
                        <div class="section-title">üñºÔ∏è Ï∂úÎ†• ÌòïÏãù</div>
                        <div class="format-options">
                            <label class="format-btn active"><input type="radio" name="format" value="png" checked><span>PNG</span></label>
                            <label class="format-btn"><input type="radio" name="format" value="jpg"><span>JPG</span></label>
                            <label class="format-btn"><input type="radio" name="format" value="webp"><span>WebP</span></label>
                        </div>
                        <div class="format-hint"><span class="hint-icon">üí°</span><span class="hint-text">PNGÎäî Î¨¥ÏÜêÏã§, JPG/WebPÎäî ÏÜêÏã§ ÏïïÏ∂ïÏûÖÎãàÎã§</span></div>
                        <div class="quality-section" id="qualitySection">
                            <label>ÌíàÏßà</label>
                            <div class="quality-row">
                                <input type="range" class="quality-slider" id="qualitySlider" min="1" max="100" value="100">
                                <input type="number" class="quality-input" id="qualityInput" min="1" max="100" value="100">
                                <span class="quality-percent">%</span>
                            </div>
                            <div class="quality-warning" id="qualityWarning">‚ö†Ô∏è ÌíàÏßà 100%Ïó¨ÎèÑ ÏõêÎ≥∏Î≥¥Îã§ ÌôîÏßà Ï†ÄÌïòÎê† Ïàò ÏûàÏùå. Î¨¥ÏÜêÏã§ ÏõêÌïòÎ©¥ PNG ÏÑ†ÌÉù!</div>
                        </div>
                    </div>
                    <button class="process-btn" id="processBtn">Ï≤òÎ¶¨ Î∞è Îã§Ïö¥Î°úÎìú</button>
                    <div class="status" id="status"></div>
                </div>
            </div>
            <div class="preview-panel" id="previewPanel">
                <div class="card">
                    <div class="preview-header"><span class="preview-title">Ïù¥ÎØ∏ÏßÄ ÎØ∏Î¶¨Î≥¥Í∏∞</span></div>
                    <div class="preview-actions-row">
                        <span class="action-label">Ï†ÑÏ≤¥</span>
                        <span class="file-count-badge" id="fileCountBadge">0Í∞ú</span>
                        <span class="action-divider"></span>
                        <span class="action-label">ÏÑ†ÌÉù</span>
                        <span class="file-count-badge secondary" id="selectedCountBadge">0Í∞ú</span>
                        <span class="action-divider"></span>
                        <button class="action-btn" id="selectAllBtn">Ï†ÑÏ≤¥ ÏÑ†ÌÉù</button>
                        <button class="action-btn" id="deselectAllBtn" disabled>ÏÑ†ÌÉù Ìï¥Ï†ú</button>
                        <button class="action-btn danger" id="deleteSelectedBtn" disabled>ÏÑ†ÌÉù ÏÇ≠Ï†ú</button>
                    </div>
                    <div class="help-text" id="helpText">üí° <span>ÌÅ¥Î¶≠</span> Îã§Ï§ë ÏÑ†ÌÉù ‚Ä¢ <span>ÎçîÎ∏îÌÅ¥Î¶≠</span> Ìé∏Ïßë ‚Ä¢ <span>Shift+ÌÅ¥Î¶≠</span> Î≤îÏúÑ ÏÑ†ÌÉù ‚Ä¢ <span>ÎìúÎûòÍ∑∏</span> ÏàúÏÑú Ïù¥Îèô</div>
                    <div class="image-grid" id="imageGrid"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-icon">üóëÔ∏è</div>
            <div class="modal-title" id="modalTitle">Ï†ïÎßê ÏÇ≠Ï†úÌï†ÍπåÏöî?</div>
            <div class="modal-desc" id="modalDesc">ÏÑ†ÌÉùÌïú Ïù¥ÎØ∏ÏßÄ 1Í∞úÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.</div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" id="modalCancel">Ï∑®ÏÜå</button>
                <button class="modal-btn confirm" id="modalConfirm">ÏÇ≠Ï†ú</button>
            </div>
        </div>
    </div>

    <div class="editor-overlay" id="editorOverlay">
        <div class="editor-container">
            <div class="editor-header">
                <span class="editor-title">üé® Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë</span>
                <div class="editor-header-btns">
                    <button class="editor-nav-btn" id="undoBtn" title="ÎêòÎèåÎ¶¨Í∏∞">‚óÄ</button>
                    <button class="editor-nav-btn" id="redoBtn" title="Îã§ÏãúÌïòÍ∏∞">‚ñ∂</button>
                    <button class="editor-close" id="editorClose">‚úï</button>
                </div>
            </div>
            <div class="editor-body">
                <div class="editor-toolbar">
                    <div class="tool-section">
                        <div class="tool-section-title">ÎèÑÍµ¨</div>
                        <div class="tool-grid">
                            <button class="tool-btn active" data-tool="brush-color" title="Îã®ÏÉâ Î∏åÎü¨Ïãú"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="8"/></svg></button>
                            <button class="tool-btn" data-tool="brush-mosaic" title="Î™®ÏûêÏù¥ÌÅ¨ Î∏åÎü¨Ïãú"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><rect x="4" y="4" width="6" height="6"/><rect x="14" y="4" width="6" height="6"/><rect x="4" y="14" width="6" height="6"/><rect x="14" y="14" width="6" height="6"/></svg></button>
                            <button class="tool-btn" data-tool="rect" title="ÏÇ¨Í∞ÅÌòï"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
                            <button class="tool-btn" data-tool="eraser" title="ÏßÄÏö∞Í∞ú"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53l-4.95-4.95l-4.95 4.95z"/></svg></button>
                        </div>
                    </div>
                    <div class="tool-divider"></div>
                    <div class="tool-section">
                        <div class="tool-section-title">ÏòµÏÖò</div>
                        <div class="option-group">
                            <div class="option-row"><span class="option-label">ÌÅ¨Í∏∞</span><input type="range" class="option-slider" id="toolSize" min="5" max="100" value="30"><input type="number" class="option-input" id="toolSizeInput" min="5" max="100" value="30"></div>
                            <div class="color-row" id="colorRow"><span class="option-label">ÏÉâÏÉÅ</span><input type="color" class="color-picker" id="toolColor" value="#000000"></div>
                        </div>
                    </div>
                </div>
                <div class="editor-canvas-area">
                    <button class="img-nav-btn prev" id="imgPrevBtn">‚óÄ</button>
                    <canvas class="editor-canvas" id="editorCanvas"></canvas>
                    <button class="img-nav-btn next" id="imgNextBtn">‚ñ∂</button>
                </div>
            </div>
            <div class="editor-footer">
                <div class="editor-shortcut"><kbd>Ctrl</kbd>+<kbd>Z</kbd> ÎêòÎèåÎ¶¨Í∏∞ ‚Ä¢ <kbd>Ctrl</kbd>+<kbd>Y</kbd> Îã§ÏãúÌïòÍ∏∞ ‚Ä¢ <kbd>ESC</kbd> Îã´Í∏∞</div>
                <div class="editor-buttons">
                    <button class="editor-btn secondary" id="editorCancel">Ï∑®ÏÜå</button>
                    <button class="editor-btn primary" id="editorSave">Ï†ÅÏö©</button>
                </div>
            </div>
        </div>
    </div>

    <div class="brush-cursor" id="brushCursor"></div>
    <div class="save-modal" id="saveModal">
        <div class="save-modal-content">
            <div class="save-modal-icon">üíæ</div>
            <div class="save-modal-title">Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÏäµÎãàÎã§</div>
            <div class="save-modal-desc">Ìé∏ÏßëÌïú ÎÇ¥Ïö©ÏùÑ Ï†ÄÏû•ÌïòÏãúÍ≤†ÏäµÎãàÍπå?</div>
            <div class="save-modal-buttons">
                <button class="save-modal-btn discard" id="saveModalDiscard">Î≤ÑÎ¶¨Í∏∞</button>
                <button class="save-modal-btn cancel" id="saveModalCancel">Ï∑®ÏÜå</button>
                <button class="save-modal-btn save" id="saveModalSave">Ï†ÄÏû•</button>
            </div>
        </div>
    </div>
    <div class="toast" id="toast"></div>

    <script>
        document.querySelectorAll('.theme-btn').forEach(btn => { btn.addEventListener('click', () => { document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); document.documentElement.setAttribute('data-theme', btn.dataset.theme); }); });
        document.querySelectorAll('.format-btn').forEach(btn => { btn.addEventListener('click', () => { document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); }); });

        const uploadArea = document.getElementById('uploadArea'), fileInput = document.getElementById('fileInput'), filenameSection = document.getElementById('filenameSection'), formatSection = document.getElementById('formatSection'), qualitySection = document.getElementById('qualitySection'), qualitySlider = document.getElementById('qualitySlider'), qualityInput = document.getElementById('qualityInput'), baseFilenameInput = document.getElementById('baseFilename'), previewPanel = document.getElementById('previewPanel'), imageGrid = document.getElementById('imageGrid'), fileCountBadge = document.getElementById('fileCountBadge'), processBtn = document.getElementById('processBtn'), deleteSelectedBtn = document.getElementById('deleteSelectedBtn'), selectAllBtn = document.getElementById('selectAllBtn'), deselectAllBtn = document.getElementById('deselectAllBtn'), selectedCountBadge = document.getElementById('selectedCountBadge'), status = document.getElementById('status'), modalOverlay = document.getElementById('modalOverlay'), modalTitle = document.getElementById('modalTitle'), modalDesc = document.getElementById('modalDesc'), modalCancel = document.getElementById('modalCancel'), modalConfirm = document.getElementById('modalConfirm'), removeMetadataToggle = document.getElementById('removeMetadata'), metadataLabel = document.getElementById('metadataLabel'), toggleSection = document.querySelector('.toggle-section'), helpText = document.getElementById('helpText'), toast = document.getElementById('toast');

        removeMetadataToggle.addEventListener('change', () => { metadataLabel.textContent = removeMetadataToggle.checked ? 'ON' : 'OFF'; });

        let selectedFiles = [], filePreviews = [], selectedIndices = new Set(), pendingDeleteAction = null, lastClickedIndex = null;
        const supportedTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let longPressTimer = null, longPressTarget = null;
        const LONG_PRESS_DURATION = 500;

        if (isMobile) helpText.innerHTML = 'üí° <span>ÌÉ≠</span> Îã§Ï§ë ÏÑ†ÌÉù ‚Ä¢ <span>ÎçîÎ∏îÌÉ≠</span> Ìé∏Ïßë ‚Ä¢ <span>Í∏∏Í≤å ÎàÑÎ•¥Í∏∞</span> Î≤îÏúÑ ÏÑ†ÌÉù ‚Ä¢ <span>ÎìúÎûòÍ∑∏</span> ÏàúÏÑú Ïù¥Îèô';

        // ÎìúÎûòÍ∑∏ Í¥ÄÎ†® Î≥ÄÏàò
        let isDraggingItems = false;
        let dropTargetIdx = null;
        let dropPosition = null;

        function showToast(message, duration = 2000) { toast.textContent = message; toast.classList.add('active'); setTimeout(() => toast.classList.remove('active'), duration); }

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); handleFiles(Array.from(e.dataTransfer.files).filter(f => supportedTypes.includes(f.type))); });
        fileInput.addEventListener('change', (e) => { handleFiles(Array.from(e.target.files).filter(f => supportedTypes.includes(f.type))); });

        document.querySelectorAll('input[name="format"]').forEach(radio => { radio.addEventListener('change', (e) => { qualitySection.classList.toggle('active', e.target.value !== 'png'); updateQualityWarning(); updateImageGrid(); }); });

        const qualityWarning = document.getElementById('qualityWarning');
        function updateQualityWarning() { const format = document.querySelector('input[name="format"]:checked').value; qualityWarning.classList.toggle('active', format !== 'png' && parseInt(qualityInput.value) >= 90); }

        qualitySlider.addEventListener('input', (e) => { qualityInput.value = e.target.value; updateQualityWarning(); });
        qualityInput.addEventListener('input', (e) => { let val = Math.max(1, Math.min(100, parseInt(e.target.value) || 1)); qualitySlider.value = val; updateQualityWarning(); });
        qualityInput.addEventListener('blur', (e) => { let val = Math.max(1, Math.min(100, parseInt(e.target.value) || 100)); e.target.value = val; qualitySlider.value = val; updateQualityWarning(); });
        baseFilenameInput.addEventListener('input', updateImageGrid);

        selectAllBtn.addEventListener('click', () => { if (selectedIndices.size === selectedFiles.length) selectedIndices.clear(); else selectedIndices = new Set(selectedFiles.map((_, i) => i)); updateImageGrid(); updateSelectionUI(); });
        deselectAllBtn.addEventListener('click', () => { if (selectedIndices.size === 0) return; selectedIndices.clear(); updateImageGrid(); updateSelectionUI(); });
        deleteSelectedBtn.addEventListener('click', () => { if (selectedIndices.size === 0) return; pendingDeleteAction = 'selected'; modalTitle.textContent = 'Ï†ïÎßê ÏÇ≠Ï†úÌï†ÍπåÏöî?'; modalDesc.textContent = `ÏÑ†ÌÉùÌïú Ïù¥ÎØ∏ÏßÄ ${selectedIndices.size}Í∞úÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.`; modalOverlay.classList.add('active'); });
        modalCancel.addEventListener('click', () => { modalOverlay.classList.remove('active'); pendingDeleteAction = null; });
        modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) { modalOverlay.classList.remove('active'); pendingDeleteAction = null; } });
        modalConfirm.addEventListener('click', () => { if (pendingDeleteAction === 'selected') { Array.from(selectedIndices).sort((a, b) => b - a).forEach(idx => { URL.revokeObjectURL(filePreviews[idx]); selectedFiles.splice(idx, 1); filePreviews.splice(idx, 1); }); selectedIndices.clear(); if (selectedFiles.length === 0) qualitySection.classList.remove('active'); } modalOverlay.classList.remove('active'); pendingDeleteAction = null; updateUI(); });

        function handleFiles(files) { if (!files.length) return; files.forEach(file => { selectedFiles.push(file); filePreviews.push(URL.createObjectURL(file)); }); updateUI(); fileInput.value = ''; }
        function updateUI() { const hasFiles = selectedFiles.length > 0; filenameSection.classList.toggle('active', hasFiles); formatSection.classList.toggle('active', hasFiles); toggleSection.classList.toggle('active', hasFiles); processBtn.classList.toggle('active', hasFiles); previewPanel.classList.toggle('active', hasFiles); fileCountBadge.textContent = `${selectedFiles.length}Í∞ú`; updateImageGrid(); updateSelectionUI(); hideStatus(); }
        function updateSelectionUI() { const count = selectedIndices.size; selectedCountBadge.textContent = `${count}Í∞ú`; deselectAllBtn.disabled = count === 0; deleteSelectedBtn.disabled = count === 0; selectAllBtn.textContent = count === selectedFiles.length && selectedFiles.length > 0 ? 'Ï†ÑÏ≤¥ Ìï¥Ï†ú' : 'Ï†ÑÏ≤¥ ÏÑ†ÌÉù'; }

        function updateImageGrid() {
            if (selectedFiles.length === 0) { imageGrid.innerHTML = '<div class="empty-state"><div class="empty-icon">üñºÔ∏è</div><div class="empty-text">Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïòÎ©¥<br>Ïó¨Í∏∞Ïóê ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä ÌëúÏãúÎê©ÎãàÎã§</div></div>'; return; }
            const baseName = baseFilenameInput.value.trim(), format = document.querySelector('input[name="format"]:checked').value;
            imageGrid.innerHTML = selectedFiles.map((file, i) => {
                let outputName = baseName === '' ? `${i + 1}.${format}` : selectedFiles.length > 1 ? `${baseName}${i + 1}.${format}` : `${baseName}.${format}`;
                return `<div class="image-item ${selectedIndices.has(i) ? 'selected' : ''}" data-index="${i}" draggable="true"><img class="image-thumb" src="${filePreviews[i]}" alt=""><div class="image-order">${i + 1}</div><div class="image-checkbox">‚úî</div><div class="image-info"><div class="image-name" title="${file.name}">${file.name}</div><div class="image-size">${formatSize(file.size)}</div><div class="image-output">‚Üí ${outputName}</div></div></div>`;
            }).join('');
            bindImageEvents();
        }

        function bindImageEvents() {
            document.querySelectorAll('.image-item').forEach(item => {
                const idx = parseInt(item.dataset.index);
                item.addEventListener('dblclick', (e) => { e.preventDefault(); openEditor(idx); });
                item.addEventListener('click', (e) => {
                    if (e.shiftKey && lastClickedIndex !== null) { const start = Math.min(lastClickedIndex, idx), end = Math.max(lastClickedIndex, idx); for (let i = start; i <= end; i++) selectedIndices.add(i); }
                    else { if (selectedIndices.has(idx)) selectedIndices.delete(idx); else selectedIndices.add(idx); lastClickedIndex = idx; }
                    updateImageGrid(); updateSelectionUI();
                });

                // ÎìúÎûòÍ∑∏ ÏãúÏûë
                item.addEventListener('dragstart', (e) => {
                    if (!selectedIndices.has(idx)) {
                        selectedIndices.clear();
                        selectedIndices.add(idx);
                        updateSelectionUI();
                    }
                    isDraggingItems = true;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', '');
                    setTimeout(() => {
                        document.querySelectorAll('.image-item').forEach(el => {
                            if (selectedIndices.has(parseInt(el.dataset.index))) el.classList.add('dragging');
                        });
                    }, 0);
                });

                // ÎìúÎûòÍ∑∏ Ïò§Î≤Ñ
                item.addEventListener('dragover', (e) => {
                    if (!isDraggingItems) return;
                    if (selectedIndices.has(idx)) return;
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    const rect = item.getBoundingClientRect();
                    const newPosition = e.clientX < rect.left + rect.width / 2 ? 'before' : 'after';
                    if (dropTargetIdx !== idx || dropPosition !== newPosition) {
                        document.querySelectorAll('.image-item').forEach(el => el.classList.remove('drop-before', 'drop-after'));
                        dropTargetIdx = idx;
                        dropPosition = newPosition;
                        item.classList.add(`drop-${newPosition}`);
                    }
                });

                item.addEventListener('dragleave', (e) => {
                    if (item.contains(e.relatedTarget)) return;
                    item.classList.remove('drop-before', 'drop-after');
                    if (dropTargetIdx === idx) { dropTargetIdx = null; dropPosition = null; }
                });

                // ÎìúÎ°≠
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (!isDraggingItems || dropTargetIdx === null) return;
                    if (selectedIndices.has(idx)) return;

                    let dropIndex = dropPosition === 'before' ? idx : idx + 1;
                    const sortedIndices = Array.from(selectedIndices).sort((a, b) => a - b);
                    const movedItems = sortedIndices.map(i => ({ file: selectedFiles[i], preview: filePreviews[i] }));

                    for (let i = sortedIndices.length - 1; i >= 0; i--) {
                        selectedFiles.splice(sortedIndices[i], 1);
                        filePreviews.splice(sortedIndices[i], 1);
                    }

                    let adjustedDropIndex = dropIndex;
                    sortedIndices.forEach(i => { if (i < dropIndex) adjustedDropIndex--; });

                    for (let i = 0; i < movedItems.length; i++) {
                        selectedFiles.splice(adjustedDropIndex + i, 0, movedItems[i].file);
                        filePreviews.splice(adjustedDropIndex + i, 0, movedItems[i].preview);
                    }

                    selectedIndices = new Set(movedItems.map((_, i) => adjustedDropIndex + i));
                    dropTargetIdx = null;
                    dropPosition = null;
                    updateImageGrid();
                    updateSelectionUI();
                });

                item.addEventListener('dragend', () => {
                    isDraggingItems = false;
                    dropTargetIdx = null;
                    dropPosition = null;
                    document.querySelectorAll('.image-item').forEach(el => el.classList.remove('dragging', 'drop-before', 'drop-after'));
                });

                if (isMobile) {
                    let touchMoved = false;
                    item.addEventListener('touchstart', () => { touchMoved = false; longPressTarget = idx; longPressTimer = setTimeout(() => { if (!touchMoved && longPressTarget === idx) { item.classList.add('long-press-active'); if (lastClickedIndex !== null) { const start = Math.min(lastClickedIndex, idx), end = Math.max(lastClickedIndex, idx); for (let i = start; i <= end; i++) selectedIndices.add(i); showToast(`${end - start + 1}Í∞ú Î≤îÏúÑ ÏÑ†ÌÉùÎê®`); } else { selectedIndices.add(idx); lastClickedIndex = idx; showToast('Î≤îÏúÑ ÏÑ†ÌÉù ÏãúÏûëÏ†ê ÏÑ§Ï†ï'); } updateImageGrid(); updateSelectionUI(); setTimeout(() => item.classList.remove('long-press-active'), 200); } }, LONG_PRESS_DURATION); }, { passive: true });
                    item.addEventListener('touchmove', () => { touchMoved = true; if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } }, { passive: true });
                    item.addEventListener('touchend', () => { if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } longPressTarget = null; }, { passive: true });
                }
            });
        }

        function formatSize(bytes) { if (bytes < 1024) return bytes + ' B'; if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB'; return (bytes / 1048576).toFixed(1) + ' MB'; }
        function scrambleAlphaLSB(imageData) { const data = imageData.data; for (let i = 3; i < data.length; i += 4) if (data[i] > 0) data[i] = (data[i] & 0xFE) | (Math.random() < 0.5 ? 0 : 1); return imageData; }

        function stripPNGMetadata(arrayBuffer) { const uint8 = new Uint8Array(arrayBuffer), view = new DataView(arrayBuffer), sig = [0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]; for (let i = 0; i < 8; i++) if (uint8[i] !== sig[i]) throw new Error('Invalid PNG'); const metaChunks = ['tEXt','iTXt','zTXt','eXIf','iCCP','sRGB','gAMA','cHRM','pHYs','sBIT','sPLT','hIST','tIME'], chunks = []; let offset = 8; while (offset < arrayBuffer.byteLength) { if (offset + 12 > arrayBuffer.byteLength) break; const length = view.getUint32(offset, false), type = String.fromCharCode(uint8[offset+4], uint8[offset+5], uint8[offset+6], uint8[offset+7]), totalSize = 12 + length; if (!metaChunks.includes(type)) chunks.push(uint8.slice(offset, offset + totalSize)); offset += totalSize; if (type === 'IEND') break; } const total = 8 + chunks.reduce((s, c) => s + c.length, 0), newBuffer = new ArrayBuffer(total), newUint8 = new Uint8Array(newBuffer); newUint8.set(sig, 0); let wo = 8; for (const chunk of chunks) { newUint8.set(chunk, wo); wo += chunk.length; } return newBuffer; }

        function stripJPEGMetadata(arrayBuffer) { const uint8 = new Uint8Array(arrayBuffer); if (uint8[0] !== 0xFF || uint8[1] !== 0xD8) throw new Error('Invalid JPEG'); const metaMarkers = new Set(); for (let i = 0xE1; i <= 0xEF; i++) metaMarkers.add(i); metaMarkers.add(0xFE); const segments = [[...uint8.slice(0, 2)]]; let offset = 2; while (offset < arrayBuffer.byteLength) { if (uint8[offset] !== 0xFF) { offset++; continue; } const marker = uint8[offset + 1]; if (marker === 0xDA) { segments.push([...uint8.slice(offset)]); break; } if (marker === 0xD9) { segments.push([...uint8.slice(offset, offset + 2)]); break; } if (marker === 0xD8 || (marker >= 0xD0 && marker <= 0xD7) || marker === 0x01) { segments.push([...uint8.slice(offset, offset + 2)]); offset += 2; continue; } if (offset + 4 > arrayBuffer.byteLength) break; const length = (uint8[offset + 2] << 8) | uint8[offset + 3], end = offset + 2 + length; if (!metaMarkers.has(marker)) segments.push([...uint8.slice(offset, end)]); offset = end; } const total = segments.reduce((s, seg) => s + seg.length, 0), newBuffer = new ArrayBuffer(total), newUint8 = new Uint8Array(newBuffer); let wo = 0; for (const seg of segments) { newUint8.set(seg, wo); wo += seg.length; } return newBuffer; }

        function stripWebPMetadata(arrayBuffer) { const view = new DataView(arrayBuffer), uint8 = new Uint8Array(arrayBuffer); if (String.fromCharCode(uint8[0],uint8[1],uint8[2],uint8[3]) !== 'RIFF' || String.fromCharCode(uint8[8],uint8[9],uint8[10],uint8[11]) !== 'WEBP') throw new Error('Invalid WebP'); const metadataChunks = ['EXIF','XMP ','ICCP'], chunks = []; let offset = 12, vp8xIdx = -1; while (offset < arrayBuffer.byteLength) { if (offset + 8 > arrayBuffer.byteLength) break; const fourCC = String.fromCharCode(uint8[offset],uint8[offset+1],uint8[offset+2],uint8[offset+3]), chunkSize = view.getUint32(offset + 4, true), paddedSize = chunkSize + (chunkSize % 2), totalSize = 8 + paddedSize; if (fourCC === 'VP8X') vp8xIdx = chunks.length; if (!metadataChunks.includes(fourCC)) chunks.push(uint8.slice(offset, offset + totalSize)); offset += totalSize; } if (vp8xIdx >= 0 && chunks[vp8xIdx].length >= 18) chunks[vp8xIdx][8] &= ~(0x20 | 0x04 | 0x08); const totalSize = chunks.reduce((s, c) => s + c.length, 0), newBuffer = new ArrayBuffer(12 + totalSize), newView = new DataView(newBuffer), newUint8 = new Uint8Array(newBuffer); newUint8.set([0x52,0x49,0x46,0x46], 0); newView.setUint32(4, 4 + totalSize, true); newUint8.set([0x57,0x45,0x42,0x50], 8); let wo = 12; for (const chunk of chunks) { newUint8.set(chunk, wo); wo += chunk.length; } return newBuffer; }

        processBtn.addEventListener('click', async () => { if (!selectedFiles.length) return; processBtn.disabled = true; processBtn.textContent = 'Ï≤òÎ¶¨ Ï§ë...'; hideStatus(); try { const baseName = baseFilenameInput.value.trim(), format = document.querySelector('input[name="format"]:checked').value, quality = parseInt(qualityInput.value) / 100, shouldRemoveMetadata = removeMetadataToggle.checked; for (let i = 0; i < selectedFiles.length; i++) { let outputName = baseName === '' ? `${i + 1}.${format}` : selectedFiles.length > 1 ? `${baseName}${i + 1}.${format}` : `${baseName}.${format}`; await processAndDownload(selectedFiles[i], outputName, format, quality, shouldRemoveMetadata); } showStatus(`‚úî ${selectedFiles.length}Í∞ú ÌååÏùº Ï≤òÎ¶¨ ÏôÑÎ£å!`, 'success'); } catch (err) { showStatus(`‚úó Ïò§Î•ò: ${err.message}`, 'error'); } processBtn.disabled = false; processBtn.textContent = 'Ï≤òÎ¶¨ Î∞è Îã§Ïö¥Î°úÎìú'; });

        async function processAndDownload(file, filename, format, quality, removeMetadata) { const arrayBuffer = await file.arrayBuffer(); let cleanedBuffer = arrayBuffer; if (removeMetadata) { if (file.type === 'image/png') cleanedBuffer = stripPNGMetadata(arrayBuffer); else if (file.type === 'image/jpeg') cleanedBuffer = stripJPEGMetadata(arrayBuffer); else if (file.type === 'image/webp') cleanedBuffer = stripWebPMetadata(arrayBuffer); } const blob = new Blob([cleanedBuffer], { type: file.type }), img = await createImageBitmap(blob), canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); if (removeMetadata) { let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); imageData = scrambleAlphaLSB(imageData); ctx.putImageData(imageData, 0, 0); } const mimeTypes = { png: 'image/png', jpg: 'image/jpeg', webp: 'image/webp' }, outputBlob = await new Promise(r => canvas.toBlob(r, mimeTypes[format], quality)), link = document.createElement('a'); link.href = URL.createObjectURL(outputBlob); link.download = filename; link.click(); URL.revokeObjectURL(link.href); }

        function showStatus(msg, type) { status.textContent = msg; status.className = `status ${type}`; }
        function hideStatus() { status.className = 'status'; }

        // ÏóêÎîîÌÑ∞
        const editorOverlay = document.getElementById('editorOverlay'), editorCanvas = document.getElementById('editorCanvas'), editorClose = document.getElementById('editorClose'), editorCancel = document.getElementById('editorCancel'), editorSave = document.getElementById('editorSave'), toolSize = document.getElementById('toolSize'), toolSizeInput = document.getElementById('toolSizeInput'), toolColor = document.getElementById('toolColor'), colorRow = document.getElementById('colorRow'), undoBtn = document.getElementById('undoBtn'), redoBtn = document.getElementById('redoBtn'), imgPrevBtn = document.getElementById('imgPrevBtn'), imgNextBtn = document.getElementById('imgNextBtn'), brushCursor = document.getElementById('brushCursor'), saveModal = document.getElementById('saveModal'), saveModalDiscard = document.getElementById('saveModalDiscard'), saveModalCancel = document.getElementById('saveModalCancel'), saveModalSave = document.getElementById('saveModalSave'), editorCtx = editorCanvas.getContext('2d');

        let editingIndex = null, originalImage = null, originalCanvas = null, currentTool = 'brush-color', isDrawing = false, lastX = 0, lastY = 0, startX = 0, startY = 0, historyStack = [], redoStack = [], tempCanvas = null, hasChanges = false, pendingAction = null;

        const canvasArea = document.querySelector('.editor-canvas-area');
        canvasArea.addEventListener('mouseenter', (e) => { if (currentTool !== 'rect') { brushCursor.classList.add('active'); updateBrushCursor(e); } });
        canvasArea.addEventListener('mousemove', updateBrushCursor);
        canvasArea.addEventListener('mouseleave', () => brushCursor.classList.remove('active'));

        function updateBrushCursor(e) { if (currentTool === 'rect') { brushCursor.classList.remove('active'); return; } const size = parseInt(toolSize.value); brushCursor.style.width = size + 'px'; brushCursor.style.height = size + 'px'; brushCursor.style.left = e.clientX + 'px'; brushCursor.style.top = e.clientY + 'px'; brushCursor.classList.toggle('mosaic', currentTool === 'brush-mosaic'); brushCursor.classList.toggle('eraser', currentTool === 'eraser'); }

        toolSize.addEventListener('input', () => toolSizeInput.value = toolSize.value);
        toolSizeInput.addEventListener('input', () => { let val = Math.max(5, Math.min(100, parseInt(toolSizeInput.value) || 5)); toolSize.value = val; });
        toolSizeInput.addEventListener('blur', () => { let val = Math.max(5, Math.min(100, parseInt(toolSizeInput.value) || 30)); toolSizeInput.value = val; toolSize.value = val; });

        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => { btn.addEventListener('click', () => { document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active')); btn.classList.add('active'); currentTool = btn.dataset.tool; colorRow.style.display = (currentTool === 'brush-mosaic' || currentTool === 'eraser') ? 'none' : 'flex'; if (currentTool === 'rect') brushCursor.classList.remove('active'); }); });

        undoBtn.addEventListener('click', undoEdit);
        redoBtn.addEventListener('click', redoEdit);

        function updateUndoRedoButtons() { undoBtn.disabled = historyStack.length <= 1; redoBtn.disabled = redoStack.length === 0; }
        function updateNavButtons() { imgPrevBtn.disabled = editingIndex <= 0; imgNextBtn.disabled = editingIndex >= selectedFiles.length - 1; }

        imgPrevBtn.addEventListener('click', () => { if (editingIndex > 0) tryNavigate(editingIndex - 1); });
        imgNextBtn.addEventListener('click', () => { if (editingIndex < selectedFiles.length - 1) tryNavigate(editingIndex + 1); });

        function tryNavigate(newIndex) { if (hasChanges) { pendingAction = { type: 'navigate', index: newIndex }; saveModal.classList.add('active'); } else switchToImage(newIndex); }
        function tryClose() { if (hasChanges) { pendingAction = { type: 'close' }; saveModal.classList.add('active'); } else closeEditor(); }

        saveModalDiscard.addEventListener('click', async () => { saveModal.classList.remove('active'); if (pendingAction) { if (pendingAction.type === 'navigate') switchToImage(pendingAction.index); else if (pendingAction.type === 'close') closeEditor(); pendingAction = null; } });
        saveModalCancel.addEventListener('click', () => { saveModal.classList.remove('active'); pendingAction = null; });
        saveModalSave.addEventListener('click', async () => { saveModal.classList.remove('active'); await applyEdit(); if (pendingAction) { if (pendingAction.type === 'navigate') switchToImage(pendingAction.index); else if (pendingAction.type === 'close') closeEditor(); pendingAction = null; } });

        function switchToImage(newIndex) { editingIndex = newIndex; historyStack = []; redoStack = []; hasChanges = false; const img = new Image(); img.onload = () => { originalImage = img; const maxSize = 800; let w = img.width, h = img.height; if (w > maxSize || h > maxSize) { if (w > h) { h = (h / w) * maxSize; w = maxSize; } else { w = (w / h) * maxSize; h = maxSize; } } editorCanvas.width = w; editorCanvas.height = h; editorCtx.drawImage(img, 0, 0, w, h); originalCanvas = document.createElement('canvas'); originalCanvas.width = w; originalCanvas.height = h; originalCanvas.getContext('2d').drawImage(img, 0, 0, w, h); saveHistory(true); updateNavButtons(); }; img.src = filePreviews[newIndex]; }

        function openEditor(index) { editingIndex = index; historyStack = []; redoStack = []; hasChanges = false; const img = new Image(); img.onload = () => { originalImage = img; const maxSize = 800; let w = img.width, h = img.height; if (w > maxSize || h > maxSize) { if (w > h) { h = (h / w) * maxSize; w = maxSize; } else { w = (w / h) * maxSize; h = maxSize; } } editorCanvas.width = w; editorCanvas.height = h; editorCtx.drawImage(img, 0, 0, w, h); originalCanvas = document.createElement('canvas'); originalCanvas.width = w; originalCanvas.height = h; originalCanvas.getContext('2d').drawImage(img, 0, 0, w, h); saveHistory(true); updateNavButtons(); editorOverlay.classList.add('active'); document.body.classList.add('editor-open'); }; img.src = filePreviews[index]; }

        function saveHistory(isInitial = false) { if (historyStack.length > 30) historyStack.shift(); historyStack.push(editorCanvas.toDataURL()); redoStack = []; updateUndoRedoButtons(); if (!isInitial) hasChanges = true; }
        function undoEdit() { if (historyStack.length <= 1) return; redoStack.push(historyStack.pop()); const img = new Image(); img.onload = () => { editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height); editorCtx.drawImage(img, 0, 0); updateUndoRedoButtons(); }; img.src = historyStack[historyStack.length - 1]; }
        function redoEdit() { if (redoStack.length === 0) return; const redo = redoStack.pop(); historyStack.push(redo); const img = new Image(); img.onload = () => { editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height); editorCtx.drawImage(img, 0, 0); updateUndoRedoButtons(); }; img.src = redo; }

        function drawMosaic(x, y, size) { const blockSize = Math.max(8, Math.floor(size / 3)), half = size / 2, sx = Math.max(0, Math.floor(x - half)), sy = Math.max(0, Math.floor(y - half)), ex = Math.min(editorCanvas.width, Math.ceil(x + half)), ey = Math.min(editorCanvas.height, Math.ceil(y + half)), imageData = editorCtx.getImageData(sx, sy, ex - sx, ey - sy), data = imageData.data; for (let by = 0; by < ey - sy; by += blockSize) { for (let bx = 0; bx < ex - sx; bx += blockSize) { let r = 0, g = 0, b = 0, count = 0; for (let py = by; py < Math.min(by + blockSize, ey - sy); py++) { for (let px = bx; px < Math.min(bx + blockSize, ex - sx); px++) { const i = (py * (ex - sx) + px) * 4; r += data[i]; g += data[i + 1]; b += data[i + 2]; count++; } } r = Math.floor(r / count); g = Math.floor(g / count); b = Math.floor(b / count); for (let py = by; py < Math.min(by + blockSize, ey - sy); py++) { for (let px = bx; px < Math.min(bx + blockSize, ex - sx); px++) { const i = (py * (ex - sx) + px) * 4; data[i] = r; data[i + 1] = g; data[i + 2] = b; } } } } editorCtx.putImageData(imageData, sx, sy); }

        function drawBrush(x, y, size, color) { editorCtx.beginPath(); editorCtx.arc(x, y, size / 2, 0, Math.PI * 2); editorCtx.fillStyle = color; editorCtx.fill(); }
        function drawBrushLine(x1, y1, x2, y2, size, color) { editorCtx.beginPath(); editorCtx.moveTo(x1, y1); editorCtx.lineTo(x2, y2); editorCtx.strokeStyle = color; editorCtx.lineWidth = size; editorCtx.lineCap = 'round'; editorCtx.stroke(); }
        function drawEraser(x, y, size) { if (!originalCanvas) return; const radius = size / 2; editorCtx.save(); editorCtx.beginPath(); editorCtx.arc(x, y, radius, 0, Math.PI * 2); editorCtx.clip(); editorCtx.drawImage(originalCanvas, 0, 0); editorCtx.restore(); }
        function drawEraserLine(x1, y1, x2, y2, size) { if (!originalCanvas) return; const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2), steps = Math.max(1, Math.floor(dist / (size / 4))); for (let i = 0; i <= steps; i++) { const t = i / steps; drawEraser(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t, size); } }

        editorCanvas.addEventListener('mousedown', (e) => { isDrawing = true; const rect = editorCanvas.getBoundingClientRect(), scaleX = editorCanvas.width / rect.width, scaleY = editorCanvas.height / rect.height; lastX = (e.clientX - rect.left) * scaleX; lastY = (e.clientY - rect.top) * scaleY; startX = lastX; startY = lastY; if (currentTool === 'rect') { tempCanvas = document.createElement('canvas'); tempCanvas.width = editorCanvas.width; tempCanvas.height = editorCanvas.height; tempCanvas.getContext('2d').drawImage(editorCanvas, 0, 0); } else if (currentTool === 'brush-mosaic') drawMosaic(lastX, lastY, parseInt(toolSize.value)); else if (currentTool === 'brush-color') drawBrush(lastX, lastY, parseInt(toolSize.value), toolColor.value); else if (currentTool === 'eraser') drawEraser(lastX, lastY, parseInt(toolSize.value)); });
        editorCanvas.addEventListener('mousemove', (e) => { if (!isDrawing) return; const rect = editorCanvas.getBoundingClientRect(), scaleX = editorCanvas.width / rect.width, scaleY = editorCanvas.height / rect.height, x = (e.clientX - rect.left) * scaleX, y = (e.clientY - rect.top) * scaleY; if (currentTool === 'brush-mosaic') drawMosaic(x, y, parseInt(toolSize.value)); else if (currentTool === 'brush-color') drawBrushLine(lastX, lastY, x, y, parseInt(toolSize.value), toolColor.value); else if (currentTool === 'eraser') drawEraserLine(lastX, lastY, x, y, parseInt(toolSize.value)); else if (currentTool === 'rect' && tempCanvas) { editorCtx.drawImage(tempCanvas, 0, 0); editorCtx.strokeStyle = toolColor.value; editorCtx.lineWidth = 2; editorCtx.setLineDash([5, 5]); editorCtx.strokeRect(Math.min(startX, x), Math.min(startY, y), Math.abs(x - startX), Math.abs(y - startY)); editorCtx.setLineDash([]); } lastX = x; lastY = y; });
        editorCanvas.addEventListener('mouseup', (e) => { if (!isDrawing) return; isDrawing = false; if (currentTool === 'rect' && tempCanvas) { const rect = editorCanvas.getBoundingClientRect(), scaleX = editorCanvas.width / rect.width, scaleY = editorCanvas.height / rect.height, x = (e.clientX - rect.left) * scaleX, y = (e.clientY - rect.top) * scaleY; editorCtx.drawImage(tempCanvas, 0, 0); editorCtx.fillStyle = toolColor.value; editorCtx.fillRect(Math.min(startX, x), Math.min(startY, y), Math.abs(x - startX), Math.abs(y - startY)); tempCanvas = null; } saveHistory(); });
        editorCanvas.addEventListener('mouseleave', () => { if (isDrawing && currentTool !== 'rect') { isDrawing = false; saveHistory(); } });

        function handleTouchStart(e) { e.preventDefault(); if (e.touches.length !== 1) return; const touch = e.touches[0], rect = editorCanvas.getBoundingClientRect(), scaleX = editorCanvas.width / rect.width, scaleY = editorCanvas.height / rect.height; isDrawing = true; lastX = (touch.clientX - rect.left) * scaleX; lastY = (touch.clientY - rect.top) * scaleY; startX = lastX; startY = lastY; if (currentTool === 'rect') { tempCanvas = document.createElement('canvas'); tempCanvas.width = editorCanvas.width; tempCanvas.height = editorCanvas.height; tempCanvas.getContext('2d').drawImage(editorCanvas, 0, 0); } else if (currentTool === 'brush-mosaic') drawMosaic(lastX, lastY, parseInt(toolSize.value)); else if (currentTool === 'brush-color') drawBrush(lastX, lastY, parseInt(toolSize.value), toolColor.value); else if (currentTool === 'eraser') drawEraser(lastX, lastY, parseInt(toolSize.value)); }
        function handleTouchMove(e) { e.preventDefault(); if (!isDrawing || e.touches.length !== 1) return; const touch = e.touches[0], rect = editorCanvas.getBoundingClientRect(), scaleX = editorCanvas.width / rect.width, scaleY = editorCanvas.height / rect.height, x = (touch.clientX - rect.left) * scaleX, y = (touch.clientY - rect.top) * scaleY; if (currentTool === 'brush-mosaic') drawMosaic(x, y, parseInt(toolSize.value)); else if (currentTool === 'brush-color') drawBrushLine(lastX, lastY, x, y, parseInt(toolSize.value), toolColor.value); else if (currentTool === 'eraser') drawEraserLine(lastX, lastY, x, y, parseInt(toolSize.value)); else if (currentTool === 'rect' && tempCanvas) { editorCtx.drawImage(tempCanvas, 0, 0); editorCtx.strokeStyle = toolColor.value; editorCtx.lineWidth = 2; editorCtx.setLineDash([5, 5]); editorCtx.strokeRect(Math.min(startX, x), Math.min(startY, y), Math.abs(x - startX), Math.abs(y - startY)); editorCtx.setLineDash([]); } lastX = x; lastY = y; }
        function handleTouchEnd(e) { e.preventDefault(); if (!isDrawing) return; isDrawing = false; if (currentTool === 'rect' && tempCanvas) { editorCtx.drawImage(tempCanvas, 0, 0); editorCtx.fillStyle = toolColor.value; editorCtx.fillRect(Math.min(startX, lastX), Math.min(startY, lastY), Math.abs(lastX - startX), Math.abs(lastY - startY)); tempCanvas = null; } saveHistory(); }

        editorCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        editorCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        editorCanvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        editorClose.addEventListener('click', tryClose);
        editorCancel.addEventListener('click', tryClose);

        function closeEditor() { editorOverlay.classList.remove('active'); document.body.classList.remove('editor-open'); brushCursor.classList.remove('active'); editingIndex = null; historyStack = []; redoStack = []; hasChanges = false; }

        async function applyEdit() { if (editingIndex === null) return; const finalCanvas = document.createElement('canvas'); finalCanvas.width = originalImage.width; finalCanvas.height = originalImage.height; const finalCtx = finalCanvas.getContext('2d'); finalCtx.drawImage(originalImage, 0, 0); finalCtx.drawImage(editorCanvas, 0, 0, originalImage.width, originalImage.height); const blob = await new Promise(r => finalCanvas.toBlob(r, 'image/png')), file = new File([blob], selectedFiles[editingIndex].name, { type: 'image/png' }); URL.revokeObjectURL(filePreviews[editingIndex]); selectedFiles[editingIndex] = file; filePreviews[editingIndex] = URL.createObjectURL(blob); hasChanges = false; updateImageGrid(); }

        editorSave.addEventListener('click', async () => { await applyEdit(); closeEditor(); });

        document.addEventListener('keydown', (e) => { if (!editorOverlay.classList.contains('active')) return; if (saveModal.classList.contains('active')) return; if (e.key === 'Escape') tryClose(); if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undoEdit(); } if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redoEdit(); } if (e.key === 'ArrowLeft' && editingIndex > 0) { e.preventDefault(); tryNavigate(editingIndex - 1); } if (e.key === 'ArrowRight' && editingIndex < selectedFiles.length - 1) { e.preventDefault(); tryNavigate(editingIndex + 1); } });
    </script>
</body>
</html>
