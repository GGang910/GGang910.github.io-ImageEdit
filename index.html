<!DOCTYPE html>
<html lang="ko" data-theme="pink">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïù¥ÎØ∏ÏßÄ ÌÅ¥Î¶¨ÎÑà</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --transition: 0.3s ease; }

        [data-theme="pink"] {
            --bg: #fff5f7; --card: #ffffff; --border: #ffccd9;
            --text: #3d3035; --text-secondary: #6d5f64;
            --accent: #ff6b96; --accent-soft: #ffb3c6; --accent-bg: #fff0f3;
            --button-text: #ffffff; --shadow: rgba(255, 107, 150, 0.2);
            --input-bg: #fff8fa; --badge-bg: #ff6b96;
            --select-bg: rgba(255, 107, 150, 0.12); --select-border: #ff6b96;
            --drag-bg: rgba(255, 107, 150, 0.15);
            --drop-zone: rgba(255, 107, 150, 0.3);
        }

        [data-theme="blue"] {
            --bg: #f5f9ff; --card: #ffffff; --border: #c5daff;
            --text: #2a3542; --text-secondary: #5a6a7a;
            --accent: #4a8cff; --accent-soft: #a3c7ff; --accent-bg: #f0f6ff;
            --button-text: #ffffff; --shadow: rgba(74, 140, 255, 0.2);
            --input-bg: #f8fbff; --badge-bg: #4a8cff;
            --select-bg: rgba(74, 140, 255, 0.12); --select-border: #4a8cff;
            --drag-bg: rgba(74, 140, 255, 0.15);
            --drop-zone: rgba(74, 140, 255, 0.3);
        }

        [data-theme="dark"] {
            --bg: #0f0f14; --card: #1a1a22; --border: #3a3a48;
            --text: #f0f0f5; --text-secondary: #a0a0b0;
            --accent: #b49cff; --accent-soft: #8b7acc; --accent-bg: #28283a;
            --button-text: #ffffff; --shadow: rgba(0, 0, 0, 0.4);
            --input-bg: #22222c; --badge-bg: #b49cff;
            --select-bg: rgba(180, 156, 255, 0.15); --select-border: #b49cff;
            --drag-bg: rgba(180, 156, 255, 0.2);
            --drop-zone: rgba(180, 156, 255, 0.4);
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            min-height: 100vh;
            padding: 32px 20px;
            transition: background var(--transition);
        }

        .wrapper { max-width: 1500px; margin: 0 auto; }

        /* ÌÖåÎßà ÏÑ†ÌÉù */
        .theme-switcher { display: flex; justify-content: center; gap: 12px; margin-bottom: 28px; }
        .theme-btn {
            width: 40px; height: 40px; border-radius: 50%;
            border: 3px solid transparent; cursor: pointer; transition: all 0.2s ease;
        }
        .theme-btn:hover { transform: scale(1.1); }
        .theme-btn.active { border-color: var(--text); transform: scale(1.1); box-shadow: 0 4px 12px var(--shadow); }
        .theme-btn.pink { background: linear-gradient(135deg, #ffb3c6, #ff6b96); }
        .theme-btn.blue { background: linear-gradient(135deg, #a3c7ff, #4a8cff); }
        .theme-btn.dark { background: linear-gradient(135deg, #4a4a5a, #1a1a22); }

        /* Î©îÏù∏ Î†àÏù¥ÏïÑÏõÉ */
        .main-layout { display: grid; grid-template-columns: 380px 1fr; gap: 28px; align-items: start; }
        @media (max-width: 1100px) { .main-layout { grid-template-columns: 1fr; } }

        .card {
            background: var(--card); border: 1px solid var(--border);
            border-radius: 24px; padding: 32px 28px;
            box-shadow: 0 8px 32px var(--shadow); transition: all var(--transition);
        }

        .settings-panel .card { position: sticky; top: 20px; }

        .header { text-align: center; margin-bottom: 28px; }
        .logo { font-size: 42px; margin-bottom: 8px; }
        h1 { font-size: 24px; font-weight: 800; color: var(--text); margin-bottom: 6px; }
        .subtitle { font-size: 14px; color: var(--text-secondary); font-weight: 500; }

        /* ÏóÖÎ°úÎìú ÏòÅÏó≠ */
        .upload-area {
            border: 2px dashed var(--border); border-radius: 16px;
            padding: 36px 20px; text-align: center; cursor: pointer;
            transition: all 0.2s ease; margin-bottom: 20px; background: var(--input-bg);
        }
        .upload-area:hover { border-color: var(--accent); background: var(--accent-bg); }
        .upload-area.dragover { border-color: var(--accent); background: var(--accent-bg); transform: scale(1.02); }
        .upload-icon { font-size: 44px; margin-bottom: 12px; }
        .upload-text { color: var(--text-secondary); font-size: 15px; font-weight: 600; line-height: 1.6; }
        .upload-text span { color: var(--accent); font-weight: 700; }
        #fileInput { display: none; }

        /* ÏÑ§Ï†ï ÏÑπÏÖò */
        .section-title { font-size: 14px; font-weight: 700; color: var(--accent); margin-bottom: 12px; text-transform: uppercase; }
        .filename-section, .format-section, .quality-section { display: none; margin-bottom: 20px; }
        .filename-section.active, .format-section.active, .quality-section.active { display: block; }

        .filename-input {
            width: 100%; padding: 14px 16px; border: 2px solid var(--border);
            border-radius: 12px; font-size: 15px; font-weight: 600;
            background: var(--input-bg); color: var(--text); transition: all 0.2s;
            font-family: inherit;
        }
        .filename-input:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 4px var(--shadow); }

        /* Ìè¨Îß∑ */
        .format-options { display: flex; gap: 10px; flex-wrap: wrap; }
        .format-btn {
            flex: 1; min-width: 70px; padding: 12px; border: 2px solid var(--border);
            border-radius: 10px; background: var(--input-bg); cursor: pointer;
            transition: all 0.2s; text-align: center;
        }
        .format-btn:hover { border-color: var(--accent-soft); }
        .format-btn.active { border-color: var(--accent); background: var(--accent-bg); }
        .format-btn input { display: none; }
        .format-btn span { font-size: 14px; font-weight: 700; color: var(--text); }
        .format-btn.active span { color: var(--accent); }

        /* ÌíàÏßà */
        .quality-section { margin-top: 16px; display: none; }
        .quality-section.active { display: block; }
        .quality-row { display: flex; align-items: center; gap: 12px; }
        .quality-slider {
            flex: 1; -webkit-appearance: none; height: 8px;
            background: var(--border); border-radius: 4px; outline: none;
        }
        .quality-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 22px; height: 22px;
            background: var(--accent); border-radius: 50%; cursor: pointer;
            box-shadow: 0 2px 8px var(--shadow);
        }
        .quality-input {
            width: 60px; padding: 8px 10px; background: var(--input-bg);
            border: 2px solid var(--border); border-radius: 8px;
            font-size: 15px; font-weight: 700; font-family: inherit;
            color: var(--accent); text-align: center; transition: all 0.2s;
        }
        .quality-input:focus {
            outline: none; border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--shadow);
        }
        .quality-input::-webkit-inner-spin-button,
        .quality-input::-webkit-outer-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .quality-percent {
            font-size: 15px; font-weight: 700; color: var(--text-secondary);
        }
        
        /* Ìè¨Îß∑ ÌûåÌä∏ */
        .format-hint {
            display: flex; align-items: center; gap: 6px;
            margin-top: 10px; padding: 8px 12px;
            background: rgba(100, 180, 255, 0.1);
            border: 1px solid rgba(100, 180, 255, 0.3);
            border-radius: 8px; font-size: 12px;
        }
        .hint-icon { font-size: 14px; }
        .hint-text { color: var(--text-secondary); font-weight: 500; }
        
        /* ÌíàÏßà Í≤ΩÍ≥† */
        .quality-warning {
            margin-top: 10px; padding: 8px 12px;
            background: rgba(255, 180, 100, 0.15);
            border: 1px solid rgba(255, 150, 50, 0.3);
            border-radius: 8px; font-size: 12px;
            color: #cc8800; font-weight: 600;
            display: none;
        }
        .quality-warning.active { display: block; }

        /* Î≤ÑÌäº */
        .process-btn {
            width: 100%; padding: 16px; border: none; border-radius: 14px;
            font-size: 16px; font-weight: 700; font-family: inherit;
            cursor: pointer; transition: all 0.2s ease; display: none;
            background: var(--accent); color: var(--button-text); margin-top: 12px;
        }
        .process-btn.active { display: block; }
        .process-btn:hover:not(:disabled) { filter: brightness(1.08); transform: translateY(-2px); box-shadow: 0 6px 20px var(--shadow); }
        .process-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        /* ÌÜ†Í∏Ä Ïä§ÏúÑÏπò */
        .toggle-section {
            margin-top: 16px; display: none;
        }
        .toggle-section.active { display: block; }
        .toggle-switch {
            display: flex; align-items: center; gap: 12px;
            cursor: pointer; user-select: none;
            padding: 10px 14px; background: var(--input-bg);
            border-radius: 10px; border: 1px solid var(--border);
        }
        .toggle-switch input { display: none; }
        .toggle-slider {
            width: 48px; height: 26px;
            background: var(--border); border-radius: 13px;
            position: relative; transition: all 0.2s;
        }
        .toggle-slider::after {
            content: '';
            position: absolute;
            width: 20px; height: 20px;
            background: white;
            border-radius: 50%;
            top: 3px; left: 3px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch input:checked + .toggle-slider {
            background: var(--accent);
        }
        .toggle-switch input:checked + .toggle-slider::after {
            left: 25px;
        }
        .toggle-label {
            font-size: 14px; font-weight: 700;
            color: var(--text-secondary);
        }
        .toggle-switch input:checked ~ .toggle-label {
            color: var(--accent);
        }

        /* Î™®Îã¨ */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5);
            display: none; justify-content: center; align-items: center;
            z-index: 2000; backdrop-filter: blur(4px);
        }
        .modal-overlay.active { display: flex; }
        
        .modal {
            background: var(--card); border: 1px solid var(--border);
            border-radius: 20px; padding: 32px; max-width: 360px; width: 90%;
            text-align: center; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalIn 0.2s ease;
        }
        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .modal-icon { font-size: 48px; margin-bottom: 16px; }
        .modal-title { font-size: 20px; font-weight: 700; color: var(--text); margin-bottom: 8px; }
        .modal-desc { font-size: 15px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.5; }
        
        .modal-buttons { display: flex; gap: 12px; }
        .modal-btn {
            flex: 1; padding: 14px; border: none; border-radius: 12px;
            font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s;
            font-family: inherit;
        }
        .modal-btn.cancel {
            background: var(--input-bg); color: var(--text-secondary); border: 2px solid var(--border);
        }
        .modal-btn.cancel:hover { border-color: var(--accent); color: var(--accent); }
        .modal-btn.confirm { background: #ff5c5c; color: white; }
        .modal-btn.confirm:hover { background: #ff4040; }

        /* ÏÉÅÌÉú Î©îÏãúÏßÄ */
        .status {
            margin-top: 16px; padding: 14px; border-radius: 12px;
            text-align: center; font-size: 15px; font-weight: 600; display: none;
        }
        .status.success { display: block; background: rgba(0, 200, 140, 0.15); color: #00b080; border: 1px solid rgba(0, 200, 140, 0.3); }
        .status.error { display: block; background: rgba(255, 90, 90, 0.15); color: #ff5050; border: 1px solid rgba(255, 90, 90, 0.3); }

        /* ========== Ïò§Î•∏Ï™Ω Ìå®ÎÑê ========== */
        .preview-panel { display: none; }
        .preview-panel.active { display: block; }

        .preview-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .preview-title { font-size: 18px; font-weight: 700; color: var(--text); }

        /* Î≤ÑÌäº Î†àÏù¥ÏïÑÏõÉ */
        .preview-actions-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            padding: 10px 14px;
            background: var(--input-bg);
            border-radius: 12px;
            border: 1px solid var(--border);
            flex-wrap: wrap;
        }
        
        .action-label {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-secondary);
        }
        
        .action-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 8px;
        }
        
        .action-btn {
            background: var(--card); border: 2px solid var(--border);
            color: var(--text-secondary); font-size: 13px; font-weight: 600;
            cursor: pointer; padding: 6px 12px; border-radius: 8px; transition: all 0.2s;
        }
        .action-btn:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
        .action-btn.danger:hover:not(:disabled) { border-color: #ff5c5c; color: #ff5c5c; background: rgba(255, 92, 92, 0.1); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .file-count-badge {
            font-size: 13px; color: var(--button-text); background: var(--badge-bg);
            padding: 4px 12px; border-radius: 16px; font-weight: 700; min-width: 40px; text-align: center;
        }
        
        .file-count-badge.secondary {
            background: var(--accent-soft);
        }

        /* ÎèÑÏõÄÎßê */
        .help-text {
            font-size: 13px; color: var(--text-secondary); margin-bottom: 16px;
            padding: 12px 14px; background: var(--input-bg); border-radius: 10px;
            border: 1px solid var(--border); font-weight: 500;
        }
        .help-text span { color: var(--accent); font-weight: 700; }

        /* Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Îìú */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            max-height: calc(100vh - 280px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 32px 60px;
            position: relative;
            background: var(--input-bg);
            border-radius: 12px;
            min-height: 200px;
        }
        
        @media (max-width: 1200px) {
            .image-grid { grid-template-columns: repeat(3, 1fr); padding: 28px 40px; }
        }
        
        @media (max-width: 900px) {
            .image-grid { grid-template-columns: repeat(2, 1fr); padding: 24px 32px; }
        }

        .image-item {
            position: relative; border-radius: 14px; overflow: hidden;
            background: var(--card); border: 3px solid var(--border);
            transition: all 0.15s ease; cursor: pointer;
        }
        .image-item:hover { border-color: var(--accent-soft); }
        .image-item.selected { border-color: var(--select-border); background: var(--select-bg); box-shadow: 0 0 0 3px var(--select-bg); }
        .image-item.dragging { opacity: 0.4; }
        .image-item.drop-target { 
            border-color: var(--accent) !important; 
            box-shadow: 0 0 0 4px var(--drop-zone) !important;
        }
        .image-item.drop-before::before {
            content: '';
            position: absolute;
            left: -14px;
            top: 0;
            bottom: 0;
            width: 6px;
            background: var(--accent);
            border-radius: 3px;
            z-index: 10;
        }
        .image-item.drop-after::after {
            content: '';
            position: absolute;
            right: -14px;
            top: 0;
            bottom: 0;
            width: 6px;
            background: var(--accent);
            border-radius: 3px;
            z-index: 10;
        }

        .image-thumb { width: 100%; aspect-ratio: 1; object-fit: cover; display: block; pointer-events: none; }

        .image-order {
            position: absolute; top: 10px; left: 10px;
            background: var(--badge-bg); color: white;
            width: 28px; height: 28px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 13px; font-weight: 700; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .image-checkbox {
            position: absolute; top: 10px; right: 10px;
            width: 24px; height: 24px; background: rgba(255,255,255,0.9);
            border: 2px solid var(--border); border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; color: transparent; pointer-events: none;
        }
        .image-item.selected .image-checkbox { background: var(--accent); border-color: var(--accent); color: white; }

        .image-info { padding: 12px 14px; }
        .image-name {
            font-size: 14px; font-weight: 600; color: var(--text);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px;
        }
        .image-size { font-size: 13px; color: var(--text-secondary); font-weight: 500; }
        .image-output {
            font-size: 13px; color: var(--accent); font-weight: 600;
            margin-top: 6px; padding-top: 6px; border-top: 1px dashed var(--border);
        }

        /* ÎìúÎûòÍ∑∏ ÏÑ†ÌÉù Î∞ïÏä§ */
        .selection-box {
            position: fixed; 
            border: 2px solid var(--accent);
            background: var(--drag-bg); 
            pointer-events: none;
            z-index: 1000; 
            border-radius: 4px;
            display: none;
        }

        /* Îπà ÏÉÅÌÉú */
        .empty-state { grid-column: 1 / -1; text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        .empty-icon { font-size: 56px; margin-bottom: 16px; opacity: 0.6; }
        .empty-text { font-size: 16px; font-weight: 500; line-height: 1.6; }

        /* Ïä§ÌÅ¨Î°§Î∞î */
        .image-grid::-webkit-scrollbar { width: 8px; }
        .image-grid::-webkit-scrollbar-track { background: var(--input-bg); border-radius: 4px; }
        .image-grid::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        .image-grid::-webkit-scrollbar-thumb:hover { background: var(--accent-soft); }

        /* Î∞òÏùëÌòï */
        @media (max-width: 600px) {
            .main-layout { gap: 20px; }
            .card { padding: 24px 20px; }
            h1 { font-size: 22px; }
            .image-item { width: 140px; }
        }

        /* ========== Ïù¥ÎØ∏ÏßÄ Ìé∏ÏßëÍ∏∞ Î™®Îã¨ ========== */
        .editor-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8);
            display: none; justify-content: center; align-items: center;
            z-index: 3000; backdrop-filter: blur(8px);
        }
        .editor-overlay.active { display: flex; }
        
        .editor-container {
            background: var(--card); border-radius: 20px;
            max-width: 95vw; max-height: 95vh;
            display: flex; flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalIn 0.2s ease;
            overflow: hidden;
        }
        
        .editor-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px 20px; border-bottom: 1px solid var(--border);
        }
        .editor-title { font-size: 18px; font-weight: 700; color: var(--text); }
        .editor-header-btns {
            display: flex; align-items: center; gap: 8px;
        }
        .editor-nav-btn {
            width: 36px; height: 36px; border-radius: 8px;
            background: var(--input-bg); border: 2px solid var(--border);
            cursor: pointer; font-size: 14px; display: flex;
            align-items: center; justify-content: center;
            color: var(--text-secondary); transition: all 0.2s;
            font-weight: 700;
        }
        .editor-nav-btn:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
        .editor-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .editor-close {
            width: 36px; height: 36px; border-radius: 50%;
            background: var(--input-bg); border: 2px solid var(--border);
            cursor: pointer; font-size: 20px; display: flex;
            align-items: center; justify-content: center;
            color: var(--text-secondary); transition: all 0.2s;
        }
        .editor-close:hover { border-color: var(--accent); color: var(--accent); }
        
        .editor-body {
            display: flex; flex: 1; overflow: hidden;
        }
        
        /* Ìà¥Î∞î */
        .editor-toolbar {
            width: 180px; background: var(--input-bg);
            border-right: 1px solid var(--border);
            padding: 16px; display: flex; flex-direction: column;
            gap: 16px;
        }
        
        .tool-section {
            display: flex; flex-direction: column; gap: 8px;
        }
        .tool-section-title {
            font-size: 11px; font-weight: 700; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        
        .tool-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
        }
        
        .tool-btn {
            aspect-ratio: 1; border-radius: 10px;
            background: var(--card); border: 2px solid var(--border);
            cursor: pointer; font-size: 16px; display: flex;
            align-items: center; justify-content: center;
            transition: all 0.15s; color: var(--text);
            flex-shrink: 0;
        }
        .tool-btn:hover { border-color: var(--accent-soft); }
        .tool-btn.active { border-color: var(--accent); background: var(--accent-bg); }
        .tool-btn-text {
            font-size: 10px; font-weight: 600; margin-top: 2px;
        }
        
        .tool-divider {
            height: 1px; background: var(--border); margin: 4px 0;
        }
        
        /* Ìà¥ ÏòµÏÖò */
        .option-group {
            display: flex; flex-direction: column; gap: 12px;
        }
        .option-row {
            display: flex; align-items: center; gap: 8px;
        }
        .option-label {
            font-size: 12px; font-weight: 600; color: var(--text-secondary);
            min-width: 36px;
        }
        .option-slider {
            flex: 1; -webkit-appearance: none; height: 6px;
            background: var(--border); border-radius: 3px; min-width: 60px;
        }
        .option-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: var(--accent); border-radius: 50%; cursor: pointer;
        }
        .option-input {
            width: 50px; padding: 6px 8px; background: var(--input-bg);
            border: 2px solid var(--border); border-radius: 6px;
            font-size: 13px; font-weight: 700; font-family: inherit;
            color: var(--accent); text-align: center;
        }
        .option-input:focus {
            outline: none; border-color: var(--accent);
        }
        .option-input::-webkit-inner-spin-button,
        .option-input::-webkit-outer-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .color-row {
            display: flex; align-items: center; gap: 8px;
        }
        .color-picker {
            flex: 1; height: 32px; border: 2px solid var(--border);
            border-radius: 8px; cursor: pointer; padding: 2px;
        }
        
        /* Ï∫îÎ≤ÑÏä§ ÏòÅÏó≠ */
        .editor-canvas-area {
            flex: 1; display: flex; align-items: center; justify-content: center;
            padding: 20px; background: var(--bg); overflow: auto;
            min-width: 500px; min-height: 400px;
            position: relative;
        }
        .editor-canvas {
            max-width: 100%; max-height: 100%;
            border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            cursor: crosshair;
        }
        
        /* Ïù¥ÎØ∏ÏßÄ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î≤ÑÌäº */
        .img-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 48px; height: 48px;
            border-radius: 50%;
            background: var(--card);
            border: 2px solid var(--border);
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text);
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10;
        }
        .img-nav-btn:hover:not(:disabled) {
            border-color: var(--accent);
            color: var(--accent);
            transform: translateY(-50%) scale(1.1);
        }
        .img-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .img-nav-btn.prev { left: 10px; }
        .img-nav-btn.next { right: 10px; }
        
        /* Î∏åÎü¨Ïãú Ïª§ÏÑú ÎØ∏Î¶¨Î≥¥Í∏∞ */
        .brush-cursor {
            position: fixed;
            border: 2px solid var(--accent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            display: none;
            transform: translate(-50%, -50%);
            background: rgba(255, 107, 150, 0.15);
        }
        .brush-cursor.active {
            display: block;
        }
        .brush-cursor.mosaic {
            border-style: dashed;
            background: rgba(128, 128, 128, 0.2);
            border-color: #666;
        }
        
        /* Ï†ÄÏû• ÌôïÏù∏ Î™®Îã¨ */
        .save-modal {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.6);
            display: none; justify-content: center; align-items: center;
            z-index: 4000; backdrop-filter: blur(4px);
        }
        .save-modal.active { display: flex; }
        .save-modal-content {
            background: var(--card); border-radius: 16px;
            padding: 28px; max-width: 380px; width: 90%;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalIn 0.2s ease;
        }
        .save-modal-icon { font-size: 48px; margin-bottom: 16px; }
        .save-modal-title { font-size: 18px; font-weight: 700; color: var(--text); margin-bottom: 8px; }
        .save-modal-desc { font-size: 14px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.5; }
        .save-modal-buttons { display: flex; gap: 10px; }
        .save-modal-btn {
            flex: 1; padding: 12px 16px; border-radius: 10px;
            font-size: 14px; font-weight: 700; cursor: pointer;
            transition: all 0.2s; font-family: inherit; border: none;
        }
        .save-modal-btn.discard {
            background: var(--input-bg); color: #ff5c5c;
            border: 2px solid #ff5c5c;
        }
        .save-modal-btn.discard:hover { background: rgba(255, 92, 92, 0.1); }
        .save-modal-btn.cancel {
            background: var(--input-bg); color: var(--text-secondary);
            border: 2px solid var(--border);
        }
        .save-modal-btn.cancel:hover { border-color: var(--accent); color: var(--accent); }
        .save-modal-btn.save {
            background: var(--accent); color: white; border: 2px solid var(--accent);
        }
        .save-modal-btn.save:hover { filter: brightness(1.1); }
        
        /* ÌïòÎã® Î≤ÑÌäº */
        .editor-footer {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px 20px; border-top: 1px solid var(--border);
        }
        .editor-shortcut {
            font-size: 12px; color: var(--text-secondary);
        }
        .editor-shortcut kbd {
            background: var(--input-bg); border: 1px solid var(--border);
            padding: 2px 6px; border-radius: 4px; font-family: inherit;
            font-weight: 600;
        }
        .editor-buttons {
            display: flex; gap: 12px;
        }
        .editor-btn {
            padding: 12px 24px; border-radius: 10px;
            font-size: 14px; font-weight: 700; cursor: pointer;
            transition: all 0.2s; font-family: inherit;
        }
        .editor-btn.secondary {
            background: var(--input-bg); border: 2px solid var(--border);
            color: var(--text-secondary);
        }
        .editor-btn.secondary:hover { border-color: var(--accent); color: var(--accent); }
        .editor-btn.primary {
            background: var(--accent); border: none; color: white;
        }
        .editor-btn.primary:hover { filter: brightness(1.1); }
    </style>
</head>
<body>
    <div class="wrapper">
        <div class="theme-switcher">
            <button class="theme-btn pink active" data-theme="pink" title="ÌïëÌÅ¨"></button>
            <button class="theme-btn blue" data-theme="blue" title="Î∏îÎ£®"></button>
            <button class="theme-btn dark" data-theme="dark" title="Îã§ÌÅ¨"></button>
        </div>

        <div class="main-layout">
            <!-- ÏôºÏ™Ω: ÏÑ§Ï†ï -->
            <div class="settings-panel">
                <div class="card">
                    <div class="header">
                        <div class="logo">üßπ</div>
                        <h1>Ïù¥ÎØ∏ÏßÄ ÌÅ¥Î¶¨ÎÑà</h1>
                        <p class="subtitle">Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ & ÏùºÍ¥Ñ Î≥ÄÌôò & Ïù¥Î¶Ñ Î≥ÄÍ≤Ω</p>
                    </div>

                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">üìÅ</div>
                        <div class="upload-text">
                            <span>ÌÅ¥Î¶≠</span> ÎòêÎäî <span>ÎìúÎûòÍ∑∏</span>Î°ú ÏóÖÎ°úÎìú<br>
                            PNG, JPG, WebP, GIF
                        </div>
                    </div>
                    <input type="file" id="fileInput" accept="image/png,image/jpeg,image/webp,image/gif" multiple>

                    <div class="filename-section" id="filenameSection">
                        <div class="section-title">üìù Ï∂úÎ†• ÌååÏùºÎ™Ö</div>
                        <input type="text" class="filename-input" id="baseFilename" placeholder="1, 2, 3... (ÎπÑÏö∞Î©¥ Ïà´ÏûêÎ°ú Ï†ÄÏû•)">
                    </div>

                    <div class="toggle-section">
                        <div class="section-title">üßπ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞</div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="removeMetadata" checked>
                            <span class="toggle-slider"></span>
                            <span class="toggle-label" id="metadataLabel">ON</span>
                        </label>
                    </div>

                    <div class="format-section" id="formatSection">
                        <div class="section-title">üñºÔ∏è Ï∂úÎ†• ÌòïÏãù</div>
                        <div class="format-options">
                            <label class="format-btn active">
                                <input type="radio" name="format" value="png" checked>
                                <span>PNG</span>
                            </label>
                            <label class="format-btn">
                                <input type="radio" name="format" value="jpg">
                                <span>JPG</span>
                            </label>
                            <label class="format-btn">
                                <input type="radio" name="format" value="webp">
                                <span>WebP</span>
                            </label>
                        </div>
                        <div class="format-hint" id="formatHint">
                            <span class="hint-icon">üí°</span>
                            <span class="hint-text">PNGÎäî Î¨¥ÏÜêÏã§, JPG/WebPÎäî ÏÜêÏã§ ÏïïÏ∂ïÏûÖÎãàÎã§</span>
                        </div>
                        
                        <div class="quality-section" id="qualitySection">
                            <label>ÌíàÏßà</label>
                            <div class="quality-row">
                                <input type="range" class="quality-slider" id="qualitySlider" min="1" max="100" value="100">
                                <input type="number" class="quality-input" id="qualityInput" min="1" max="100" value="100">
                                <span class="quality-percent">%</span>
                            </div>
                            <div class="quality-warning" id="qualityWarning">
                                ‚ö†Ô∏è ÌíàÏßà 100%Ïó¨ÎèÑ ÏõêÎ≥∏Î≥¥Îã§ ÌôîÏßà Ï†ÄÌïòÎê† Ïàò ÏûàÏùå. Î¨¥ÏÜêÏã§ ÏõêÌïòÎ©¥ PNG ÏÑ†ÌÉù!
                            </div>
                        </div>
                    </div>

                    <button class="process-btn" id="processBtn">Ï≤òÎ¶¨ Î∞è Îã§Ïö¥Î°úÎìú</button>
                    
                    <div class="status" id="status"></div>
                </div>
            </div>

            <!-- Ïò§Î•∏Ï™Ω: ÎØ∏Î¶¨Î≥¥Í∏∞ -->
            <div class="preview-panel" id="previewPanel">
                <div class="card">
                    <div class="preview-header">
                        <span class="preview-title">Ïù¥ÎØ∏ÏßÄ ÎØ∏Î¶¨Î≥¥Í∏∞</span>
                    </div>
                    <div class="preview-actions-row">
                        <span class="action-label">Ï†ÑÏ≤¥</span>
                        <span class="file-count-badge" id="fileCountBadge">0Í∞ú</span>
                        <span class="action-divider"></span>
                        <span class="action-label">ÏÑ†ÌÉù</span>
                        <span class="file-count-badge secondary" id="selectedCountBadge">0Í∞ú</span>
                        <span class="action-divider"></span>
                        <button class="action-btn" id="selectAllBtn">Ï†ÑÏ≤¥ ÏÑ†ÌÉù</button>
                        <button class="action-btn" id="deselectAllBtn" disabled>ÏÑ†ÌÉù Ìï¥Ï†ú</button>
                        <button class="action-btn danger" id="deleteSelectedBtn" disabled>ÏÑ†ÌÉù ÏÇ≠Ï†ú</button>
                    </div>
                    <div class="help-text">
                        üí° <span>ÌÅ¥Î¶≠</span> ÏÑ†ÌÉù ‚Ä¢ <span>ÎçîÎ∏îÌÅ¥Î¶≠</span> Ìé∏Ïßë ‚Ä¢ <span>Ctrl+ÌÅ¥Î¶≠</span> Îã§Ï§ë ÏÑ†ÌÉù ‚Ä¢ <span>Shift+ÌÅ¥Î¶≠</span> Î≤îÏúÑ ÏÑ†ÌÉù ‚Ä¢ <span>ÎìúÎûòÍ∑∏</span> Î∞ïÏä§ ÏÑ†ÌÉù/ÏàúÏÑú Ïù¥Îèô
                    </div>
                    <div class="image-grid" id="imageGrid"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ÎìúÎûòÍ∑∏ ÏÑ†ÌÉù Î∞ïÏä§ -->
    <div class="selection-box" id="selectionBox"></div>

    <!-- ÏÇ≠Ï†ú ÌôïÏù∏ Î™®Îã¨ -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-icon">üóëÔ∏è</div>
            <div class="modal-title" id="modalTitle">Ï†ïÎßê ÏÇ≠Ï†úÌï†ÍπåÏöî?</div>
            <div class="modal-desc" id="modalDesc">ÏÑ†ÌÉùÌïú Ïù¥ÎØ∏ÏßÄ 1Í∞úÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.</div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" id="modalCancel">Ï∑®ÏÜå</button>
                <button class="modal-btn confirm" id="modalConfirm">ÏÇ≠Ï†ú</button>
            </div>
        </div>
    </div>

    <!-- Ïù¥ÎØ∏ÏßÄ Ìé∏ÏßëÍ∏∞ Î™®Îã¨ -->
    <div class="editor-overlay" id="editorOverlay">
        <div class="editor-container">
            <div class="editor-header">
                <span class="editor-title">üé® Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë</span>
                <div class="editor-header-btns">
                    <button class="editor-nav-btn" id="undoBtn" title="ÎêòÎèåÎ¶¨Í∏∞ (Ctrl+Z)">‚óÄ</button>
                    <button class="editor-nav-btn" id="redoBtn" title="Îã§ÏãúÌïòÍ∏∞ (Ctrl+Y)">‚ñ∂</button>
                    <button class="editor-close" id="editorClose">‚úï</button>
                </div>
            </div>
            <div class="editor-body">
                <div class="editor-toolbar">
                    <!-- ÎèÑÍµ¨ ÏÑ†ÌÉù -->
                    <div class="tool-section">
                        <div class="tool-section-title">ÎèÑÍµ¨</div>
                        <div class="tool-grid">
                            <button class="tool-btn active" data-tool="brush-color" title="Îã®ÏÉâ Î∏åÎü¨Ïãú">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <circle cx="12" cy="12" r="8"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-tool="brush-mosaic" title="Î™®ÏûêÏù¥ÌÅ¨ Î∏åÎü¨Ïãú">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="4" y="4" width="6" height="6"/>
                                    <rect x="14" y="4" width="6" height="6"/>
                                    <rect x="4" y="14" width="6" height="6"/>
                                    <rect x="14" y="14" width="6" height="6"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-tool="rect" title="ÏÇ¨Í∞ÅÌòï">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    
                    <div class="tool-divider"></div>
                    
                    <!-- ÏòµÏÖò -->
                    <div class="tool-section">
                        <div class="tool-section-title">ÏòµÏÖò</div>
                        <div class="option-group">
                            <div class="option-row">
                                <span class="option-label">ÌÅ¨Í∏∞</span>
                                <input type="range" class="option-slider" id="toolSize" min="5" max="100" value="30">
                                <input type="number" class="option-input" id="toolSizeInput" min="5" max="100" value="30">
                            </div>
                            <div class="color-row" id="colorRow">
                                <span class="option-label">ÏÉâÏÉÅ</span>
                                <input type="color" class="color-picker" id="toolColor" value="#000000">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-canvas-area">
                    <button class="img-nav-btn prev" id="imgPrevBtn" title="Ïù¥Ï†Ñ Ïù¥ÎØ∏ÏßÄ">‚óÄ</button>
                    <canvas class="editor-canvas" id="editorCanvas"></canvas>
                    <button class="img-nav-btn next" id="imgNextBtn" title="Îã§Ïùå Ïù¥ÎØ∏ÏßÄ">‚ñ∂</button>
                </div>
            </div>
            <div class="editor-footer">
                <div class="editor-shortcut">
                    <kbd>Ctrl</kbd>+<kbd>Z</kbd> ÎêòÎèåÎ¶¨Í∏∞ ‚Ä¢ <kbd>Ctrl</kbd>+<kbd>Y</kbd> Îã§ÏãúÌïòÍ∏∞ ‚Ä¢ <kbd>ESC</kbd> Îã´Í∏∞
                </div>
                <div class="editor-buttons">
                    <button class="editor-btn secondary" id="editorCancel">Ï∑®ÏÜå</button>
                    <button class="editor-btn primary" id="editorSave">Ï†ÅÏö©</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Î∏åÎü¨Ïãú Ïª§ÏÑú ÎØ∏Î¶¨Î≥¥Í∏∞ -->
    <div class="brush-cursor" id="brushCursor"></div>

    <!-- Ï†ÄÏû• ÌôïÏù∏ Î™®Îã¨ -->
    <div class="save-modal" id="saveModal">
        <div class="save-modal-content">
            <div class="save-modal-icon">üíæ</div>
            <div class="save-modal-title">Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÏäµÎãàÎã§</div>
            <div class="save-modal-desc">Ìé∏ÏßëÌïú ÎÇ¥Ïö©ÏùÑ Ï†ÄÏû•ÌïòÏãúÍ≤†ÏäµÎãàÍπå?</div>
            <div class="save-modal-buttons">
                <button class="save-modal-btn discard" id="saveModalDiscard">Î≤ÑÎ¶¨Í∏∞</button>
                <button class="save-modal-btn cancel" id="saveModalCancel">Ï∑®ÏÜå</button>
                <button class="save-modal-btn save" id="saveModalSave">Ï†ÄÏû•</button>
            </div>
        </div>
    </div>

    <script>
        // ÌÖåÎßà Ï†ÑÌôò
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.documentElement.setAttribute('data-theme', btn.dataset.theme);
            });
        });

        // Ìè¨Îß∑ ÏÑ†ÌÉù
        document.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // ÏöîÏÜå Ï∞∏Ï°∞
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const filenameSection = document.getElementById('filenameSection');
        const formatSection = document.getElementById('formatSection');
        const qualitySection = document.getElementById('qualitySection');
        const qualitySlider = document.getElementById('qualitySlider');
        const qualityInput = document.getElementById('qualityInput');
        const baseFilenameInput = document.getElementById('baseFilename');
        const previewPanel = document.getElementById('previewPanel');
        const imageGrid = document.getElementById('imageGrid');
        const fileCountBadge = document.getElementById('fileCountBadge');
        const processBtn = document.getElementById('processBtn');
        const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const selectedCountBadge = document.getElementById('selectedCountBadge');
        const status = document.getElementById('status');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalDesc = document.getElementById('modalDesc');
        const modalCancel = document.getElementById('modalCancel');
        const modalConfirm = document.getElementById('modalConfirm');
        const selectionBox = document.getElementById('selectionBox');
        const removeMetadataToggle = document.getElementById('removeMetadata');
        const metadataLabel = document.getElementById('metadataLabel');
        const toggleSection = document.querySelector('.toggle-section');

        // ÌÜ†Í∏Ä Ïù¥Î≤§Ìä∏
        removeMetadataToggle.addEventListener('change', () => {
            metadataLabel.textContent = removeMetadataToggle.checked ? 'ON' : 'OFF';
        });

        let selectedFiles = [];
        let filePreviews = [];
        let selectedIndices = new Set();
        let pendingDeleteAction = null;
        let lastClickedIndex = null;
        const supportedTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/gif'];

        // ÎìúÎûòÍ∑∏ Í¥ÄÎ†® Î≥ÄÏàò
        let isDragSelecting = false;
        let isDraggingItems = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartScrollTop = 0;
        let preSelectIndices = new Set();

        // ÌååÏùº ÏóÖÎ°úÎìú
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(Array.from(e.dataTransfer.files).filter(f => supportedTypes.includes(f.type)));
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files).filter(f => supportedTypes.includes(f.type)));
        });

        document.querySelectorAll('input[name="format"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                qualitySection.classList.toggle('active', e.target.value !== 'png');
                updateQualityWarning();
                updateImageGrid();
            });
        });

        const qualityWarning = document.getElementById('qualityWarning');
        
        function updateQualityWarning() {
            const format = document.querySelector('input[name="format"]:checked').value;
            const quality = parseInt(qualityInput.value);
            // JPG/WebPÏù¥Í≥† ÌíàÏßà 90% Ïù¥ÏÉÅÏù¥Î©¥ Í≤ΩÍ≥†
            qualityWarning.classList.toggle('active', format !== 'png' && quality >= 90);
        }

        qualitySlider.addEventListener('input', (e) => {
            qualityInput.value = e.target.value;
            updateQualityWarning();
        });
        
        qualityInput.addEventListener('input', (e) => {
            let val = parseInt(e.target.value) || 1;
            val = Math.max(1, Math.min(100, val));
            qualitySlider.value = val;
            updateQualityWarning();
        });
        
        qualityInput.addEventListener('blur', (e) => {
            let val = parseInt(e.target.value) || 100;
            val = Math.max(1, Math.min(100, val));
            e.target.value = val;
            qualitySlider.value = val;
            updateQualityWarning();
        });
        
        baseFilenameInput.addEventListener('input', updateImageGrid);

        // Ï†ÑÏ≤¥ ÏÑ†ÌÉù/Ìï¥Ï†ú Î≤ÑÌäº
        selectAllBtn.addEventListener('click', () => {
            if (selectedIndices.size === selectedFiles.length) {
                selectedIndices.clear();
            } else {
                selectedIndices = new Set(selectedFiles.map((_, i) => i));
            }
            updateImageGrid();
            updateSelectionUI();
        });
        
        // ÏÑ†ÌÉù Ìï¥Ï†ú Î≤ÑÌäº
        deselectAllBtn.addEventListener('click', () => {
            if (selectedIndices.size === 0) return;
            selectedIndices.clear();
            updateImageGrid();
            updateSelectionUI();
        });

        // ÏÑ†ÌÉù ÏÇ≠Ï†ú Î≤ÑÌäº
        deleteSelectedBtn.addEventListener('click', () => {
            if (selectedIndices.size === 0) return;
            pendingDeleteAction = 'selected';
            modalTitle.textContent = 'Ï†ïÎßê ÏÇ≠Ï†úÌï†ÍπåÏöî?';
            modalDesc.textContent = `ÏÑ†ÌÉùÌïú Ïù¥ÎØ∏ÏßÄ ${selectedIndices.size}Í∞úÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.`;
            modalOverlay.classList.add('active');
        });

        // Î™®Îã¨
        modalCancel.addEventListener('click', () => {
            modalOverlay.classList.remove('active');
            pendingDeleteAction = null;
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.classList.remove('active');
                pendingDeleteAction = null;
            }
        });

        modalConfirm.addEventListener('click', () => {
            if (pendingDeleteAction === 'selected') {
                const indicesToDelete = Array.from(selectedIndices).sort((a, b) => b - a);
                indicesToDelete.forEach(idx => {
                    URL.revokeObjectURL(filePreviews[idx]);
                    selectedFiles.splice(idx, 1);
                    filePreviews.splice(idx, 1);
                });
                selectedIndices.clear();
                
                if (selectedFiles.length === 0) {
                    qualitySection.classList.remove('active');
                }
            }
            
            modalOverlay.classList.remove('active');
            pendingDeleteAction = null;
            updateUI();
        });

        function handleFiles(files) {
            if (!files.length) return;

            files.forEach(file => {
                selectedFiles.push(file);
                filePreviews.push(URL.createObjectURL(file));
            });

            updateUI();
            fileInput.value = '';
        }

        function updateUI() {
            const hasFiles = selectedFiles.length > 0;
            
            filenameSection.classList.toggle('active', hasFiles);
            formatSection.classList.toggle('active', hasFiles);
            toggleSection.classList.toggle('active', hasFiles);
            processBtn.classList.toggle('active', hasFiles);
            previewPanel.classList.toggle('active', hasFiles);
            
            fileCountBadge.textContent = `${selectedFiles.length}Í∞ú`;
            
            updateImageGrid();
            updateSelectionUI();
            hideStatus();
        }

        function updateSelectionUI() {
            const count = selectedIndices.size;
            const hasSelection = count > 0;
            const isAllSelected = count === selectedFiles.length && selectedFiles.length > 0;
            
            selectedCountBadge.textContent = `${count}Í∞ú`;
            
            deselectAllBtn.disabled = !hasSelection;
            deleteSelectedBtn.disabled = !hasSelection;
            
            selectAllBtn.textContent = isAllSelected ? 'Ï†ÑÏ≤¥ Ìï¥Ï†ú' : 'Ï†ÑÏ≤¥ ÏÑ†ÌÉù';
        }

        function updateImageGrid() {
            if (selectedFiles.length === 0) {
                imageGrid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üñºÔ∏è</div>
                        <div class="empty-text">Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïòÎ©¥<br>Ïó¨Í∏∞Ïóê ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä ÌëúÏãúÎê©ÎãàÎã§</div>
                    </div>
                `;
                return;
            }

            const baseName = baseFilenameInput.value.trim();
            const format = document.querySelector('input[name="format"]:checked').value;

            imageGrid.innerHTML = selectedFiles.map((file, i) => {
                let outputName;
                if (baseName === '') {
                    // ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ïà´ÏûêÎßå
                    outputName = `${i + 1}.${format}`;
                } else if (selectedFiles.length > 1) {
                    outputName = `${baseName}${i + 1}.${format}`;
                } else {
                    outputName = `${baseName}.${format}`;
                }
                const isSelected = selectedIndices.has(i);

                return `
                    <div class="image-item ${isSelected ? 'selected' : ''}" data-index="${i}" draggable="true">
                        <img class="image-thumb" src="${filePreviews[i]}" alt="">
                        <div class="image-order">${i + 1}</div>
                        <div class="image-checkbox">‚úì</div>
                        <div class="image-info">
                            <div class="image-name" title="${file.name}">${file.name}</div>
                            <div class="image-size">${formatSize(file.size)}</div>
                            <div class="image-output">‚Üí ${outputName}</div>
                        </div>
                    </div>
                `;
            }).join('');

            bindImageEvents();
        }

        function bindImageEvents() {
            const items = document.querySelectorAll('.image-item');
            let dropTargetIdx = null;
            let dropPosition = null; // 'before' or 'after'
            
            items.forEach(item => {
                const idx = parseInt(item.dataset.index);
                
                // ÎçîÎ∏îÌÅ¥Î¶≠ - Ìé∏ÏßëÍ∏∞ Ïó¥Í∏∞
                item.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    openEditor(idx);
                });
                
                // ÌÅ¥Î¶≠ - ÏúàÎèÑÏö∞ Ïä§ÌÉÄÏùº
                item.addEventListener('click', (e) => {
                    // Ctrl+ÌÅ¥Î¶≠: ÌÜ†Í∏Ä
                    if (e.ctrlKey || e.metaKey) {
                        if (selectedIndices.has(idx)) {
                            selectedIndices.delete(idx);
                        } else {
                            selectedIndices.add(idx);
                        }
                        lastClickedIndex = idx;
                    }
                    // Shift+ÌÅ¥Î¶≠: Î≤îÏúÑ ÏÑ†ÌÉù
                    else if (e.shiftKey && lastClickedIndex !== null) {
                        const start = Math.min(lastClickedIndex, idx);
                        const end = Math.max(lastClickedIndex, idx);
                        
                        if (!e.ctrlKey && !e.metaKey) {
                            selectedIndices.clear();
                        }
                        
                        for (let i = start; i <= end; i++) {
                            selectedIndices.add(i);
                        }
                    }
                    // ÏùºÎ∞ò ÌÅ¥Î¶≠: Îã®Ïùº ÏÑ†ÌÉù
                    else {
                        selectedIndices.clear();
                        selectedIndices.add(idx);
                        lastClickedIndex = idx;
                    }
                    
                    updateImageGrid();
                    updateSelectionUI();
                });

                // ÎìúÎûòÍ∑∏ ÏãúÏûë
                item.addEventListener('dragstart', (e) => {
                    if (!selectedIndices.has(idx)) {
                        selectedIndices.clear();
                        selectedIndices.add(idx);
                        updateImageGrid();
                        updateSelectionUI();
                        // Îã§Ïãú Ïù¥Î≤§Ìä∏ Î∞îÏù∏Îî© ÌõÑ ÌòÑÏû¨ ÏïÑÏù¥ÌÖú Ï∞æÍ∏∞
                        const newItem = document.querySelector(`.image-item[data-index="${idx}"]`);
                        if (newItem) newItem.classList.add('dragging');
                    }
                    
                    isDraggingItems = true;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', '');
                    
                    setTimeout(() => {
                        document.querySelectorAll('.image-item').forEach(el => {
                            const elIdx = parseInt(el.dataset.index);
                            if (selectedIndices.has(elIdx)) {
                                el.classList.add('dragging');
                            }
                        });
                    }, 0);
                });

                // ÎìúÎûòÍ∑∏ Ïò§Î≤Ñ - Ïïû/Îí§ ÌåêÎã®
                item.addEventListener('dragover', (e) => {
                    if (!isDraggingItems) return;
                    if (selectedIndices.has(idx)) return; // ÏûêÍ∏∞ ÏûêÏã†ÏùÄ Î¨¥Ïãú
                    
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const rect = item.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    
                    // ÎßàÏö∞Ïä§ ÏúÑÏπòÍ∞Ä Ï§ëÏïô Í∏∞Ï§Ä ÏôºÏ™ΩÏù¥Î©¥ before, Ïò§Î•∏Ï™ΩÏù¥Î©¥ after
                    const newPosition = e.clientX < midX ? 'before' : 'after';
                    
                    if (dropTargetIdx !== idx || dropPosition !== newPosition) {
                        // Ïù¥Ï†Ñ ÌëúÏãú Ï†úÍ±∞
                        document.querySelectorAll('.image-item').forEach(el => {
                            el.classList.remove('drop-target', 'drop-before', 'drop-after');
                        });
                        
                        dropTargetIdx = idx;
                        dropPosition = newPosition;
                        
                        item.classList.add('drop-target', `drop-${newPosition}`);
                    }
                });

                item.addEventListener('dragleave', (e) => {
                    // ÏûêÏãù ÏöîÏÜåÎ°ú Ïù¥ÎèôÌï† ÎïåÎäî Î¨¥Ïãú
                    if (item.contains(e.relatedTarget)) return;
                    
                    item.classList.remove('drop-target', 'drop-before', 'drop-after');
                    if (dropTargetIdx === idx) {
                        dropTargetIdx = null;
                        dropPosition = null;
                    }
                });

                // ÎìúÎ°≠
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    if (!isDraggingItems || dropTargetIdx === null) return;
                    if (selectedIndices.has(idx)) return;
                    
                    // ÎìúÎ°≠ Ïù∏Îç±Ïä§ Í≥ÑÏÇ∞
                    let dropIndex = dropPosition === 'before' ? idx : idx + 1;
                    
                    // ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖúÎì§ Ï∂îÏ∂ú
                    const sortedIndices = Array.from(selectedIndices).sort((a, b) => a - b);
                    const movedItems = sortedIndices.map(i => ({
                        file: selectedFiles[i],
                        preview: filePreviews[i]
                    }));
                    
                    // ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖúÎì§ Ï†úÍ±∞ (Îí§ÏóêÏÑúÎ∂ÄÌÑ∞)
                    for (let i = sortedIndices.length - 1; i >= 0; i--) {
                        selectedFiles.splice(sortedIndices[i], 1);
                        filePreviews.splice(sortedIndices[i], 1);
                    }
                    
                    // ÎìúÎ°≠ ÏúÑÏπò Ï°∞Ï†ï (Ï†úÍ±∞Îêú ÏïÑÏù¥ÌÖú Î∞òÏòÅ)
                    let adjustedDropIndex = dropIndex;
                    sortedIndices.forEach(i => {
                        if (i < dropIndex) adjustedDropIndex--;
                    });
                    
                    // ÏÇΩÏûÖ
                    for (let i = 0; i < movedItems.length; i++) {
                        selectedFiles.splice(adjustedDropIndex + i, 0, movedItems[i].file);
                        filePreviews.splice(adjustedDropIndex + i, 0, movedItems[i].preview);
                    }
                    
                    // ÏÑ†ÌÉù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    selectedIndices = new Set(movedItems.map((_, i) => adjustedDropIndex + i));
                    
                    dropTargetIdx = null;
                    dropPosition = null;
                    
                    updateImageGrid();
                    updateSelectionUI();
                });

                item.addEventListener('dragend', () => {
                    isDraggingItems = false;
                    dropTargetIdx = null;
                    dropPosition = null;
                    document.querySelectorAll('.image-item').forEach(el => {
                        el.classList.remove('dragging', 'drop-target', 'drop-before', 'drop-after');
                    });
                });
            });
        }

        // =====================================================
        // ÎìúÎûòÍ∑∏ Î∞ïÏä§ ÏÑ†ÌÉù (ÏúàÎèÑÏö∞ Ïä§ÌÉÄÏùº)
        // =====================================================
        
        imageGrid.addEventListener('mousedown', (e) => {
            // Ïù¥ÎØ∏ÏßÄ ÏïÑÏù¥ÌÖú ÏúÑÏóêÏÑú ÏãúÏûëÌïòÎ©¥ Î¨¥Ïãú
            if (e.target.closest('.image-item')) return;
            if (e.target.closest('.drop-zone')) return;
            
            isDragSelecting = true;
            
            const gridRect = imageGrid.getBoundingClientRect();
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartScrollTop = imageGrid.scrollTop;
            
            // Ctrl Ïïà ÎàÑÎ•¥Î©¥ Í∏∞Ï°¥ ÏÑ†ÌÉù Ìï¥Ï†ú
            if (!e.ctrlKey && !e.metaKey) {
                selectedIndices.clear();
                updateImageGrid();
                updateSelectionUI();
            }
            
            preSelectIndices = new Set(selectedIndices);
            
            selectionBox.style.display = 'block';
            selectionBox.style.left = e.clientX + 'px';
            selectionBox.style.top = e.clientY + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragSelecting) return;
            
            const gridRect = imageGrid.getBoundingClientRect();
            
            // Ïä§ÌÅ¨Î°§ Î≥¥Ï†ï
            const scrollDiff = imageGrid.scrollTop - dragStartScrollTop;
            const adjustedStartY = dragStartY - scrollDiff;
            
            const currentX = e.clientX;
            const currentY = e.clientY;
            
            const left = Math.min(dragStartX, currentX);
            const top = Math.min(adjustedStartY, currentY);
            const width = Math.abs(currentX - dragStartX);
            const height = Math.abs(currentY - adjustedStartY);
            
            // Í∑∏Î¶¨Îìú ÏòÅÏó≠Ïóê ÌÅ¥Î¶¨Ìïë
            const clipLeft = Math.max(left, gridRect.left);
            const clipTop = Math.max(top, gridRect.top);
            const clipRight = Math.min(left + width, gridRect.right);
            const clipBottom = Math.min(top + height, gridRect.bottom);
            
            selectionBox.style.left = clipLeft + 'px';
            selectionBox.style.top = clipTop + 'px';
            selectionBox.style.width = Math.max(0, clipRight - clipLeft) + 'px';
            selectionBox.style.height = Math.max(0, clipBottom - clipTop) + 'px';
            
            // ÏÑ†ÌÉù Î∞ïÏä§ rect
            const boxRect = {
                left: left,
                right: left + width,
                top: top,
                bottom: top + height
            };
            
            // ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù Ï≤¥ÌÅ¨
            document.querySelectorAll('.image-item').forEach(item => {
                const idx = parseInt(item.dataset.index);
                const itemRect = item.getBoundingClientRect();
                
                const isOverlapping = !(
                    boxRect.right < itemRect.left ||
                    boxRect.left > itemRect.right ||
                    boxRect.bottom < itemRect.top ||
                    boxRect.top > itemRect.bottom
                );
                
                // ÏúàÎèÑÏö∞ Ïä§ÌÉÄÏùº: ÌÜ†Í∏Ä
                if (isOverlapping) {
                    if (preSelectIndices.has(idx)) {
                        selectedIndices.delete(idx);
                    } else {
                        selectedIndices.add(idx);
                    }
                } else {
                    if (preSelectIndices.has(idx)) {
                        selectedIndices.add(idx);
                    } else {
                        selectedIndices.delete(idx);
                    }
                }
                
                item.classList.toggle('selected', selectedIndices.has(idx));
            });
            
            updateSelectionUI();
        });

        document.addEventListener('mouseup', () => {
            if (isDragSelecting) {
                isDragSelecting = false;
                selectionBox.style.display = 'none';
                preSelectIndices.clear();
                updateImageGrid();
            }
        });

        // Í∑∏Î¶¨Îìú Ïä§ÌÅ¨Î°§ Ïãú ÏÑ†ÌÉù Î∞ïÏä§ ÏóÖÎç∞Ïù¥Ìä∏
        imageGrid.addEventListener('scroll', () => {
            if (!isDragSelecting) return;
            // mousemove Ïù¥Î≤§Ìä∏ Í∞ïÏ†ú Î∞úÏÉù
            document.dispatchEvent(new MouseEvent('mousemove', {
                clientX: parseInt(selectionBox.style.left) + parseInt(selectionBox.style.width),
                clientY: parseInt(selectionBox.style.top) + parseInt(selectionBox.style.height)
            }));
        });

        function toggleSelect(idx) {
            if (selectedIndices.has(idx)) {
                selectedIndices.delete(idx);
            } else {
                selectedIndices.add(idx);
            }
            updateImageGrid();
            updateSelectionUI();
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // =====================================================
        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ Î°úÏßÅ
        // =====================================================

        function scrambleAlphaLSB(imageData) {
            const data = imageData.data;
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] > 0) {
                    data[i] = (data[i] & 0xFE) | (Math.random() < 0.5 ? 0 : 1);
                }
            }
            return imageData;
        }

        function stripWebPMetadata(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const uint8 = new Uint8Array(arrayBuffer);
            
            const riff = String.fromCharCode(uint8[0], uint8[1], uint8[2], uint8[3]);
            const webp = String.fromCharCode(uint8[8], uint8[9], uint8[10], uint8[11]);
            
            if (riff !== 'RIFF' || webp !== 'WEBP') throw new Error('Invalid WebP');
            
            const metadataChunks = ['EXIF', 'XMP ', 'ICCP'];
            const FLAG_XMP = 0x04, FLAG_EXIF = 0x08, FLAG_ICCP = 0x20;
            
            const chunks = [];
            let offset = 12;
            let vp8xIdx = -1;
            
            while (offset < arrayBuffer.byteLength) {
                if (offset + 8 > arrayBuffer.byteLength) break;
                const fourCC = String.fromCharCode(uint8[offset], uint8[offset+1], uint8[offset+2], uint8[offset+3]);
                const chunkSize = view.getUint32(offset + 4, true);
                const paddedSize = chunkSize + (chunkSize % 2);
                const totalSize = 8 + paddedSize;
                
                if (fourCC === 'VP8X') vp8xIdx = chunks.length;
                
                if (!metadataChunks.includes(fourCC)) {
                    chunks.push(uint8.slice(offset, offset + totalSize));
                }
                offset += totalSize;
            }
            
            if (vp8xIdx >= 0 && chunks[vp8xIdx].length >= 18) {
                let flags = chunks[vp8xIdx][8];
                flags &= ~(FLAG_ICCP | FLAG_XMP | FLAG_EXIF);
                chunks[vp8xIdx][8] = flags;
            }
            
            const totalSize = chunks.reduce((s, c) => s + c.length, 0);
            const newBuffer = new ArrayBuffer(12 + totalSize);
            const newView = new DataView(newBuffer);
            const newUint8 = new Uint8Array(newBuffer);
            
            newUint8.set([0x52, 0x49, 0x46, 0x46], 0);
            newView.setUint32(4, 4 + totalSize, true);
            newUint8.set([0x57, 0x45, 0x42, 0x50], 8);
            
            let wo = 12;
            for (const chunk of chunks) { newUint8.set(chunk, wo); wo += chunk.length; }
            
            return newBuffer;
        }

        function stripPNGMetadata(arrayBuffer) {
            const uint8 = new Uint8Array(arrayBuffer);
            const view = new DataView(arrayBuffer);
            
            const sig = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
            for (let i = 0; i < 8; i++) if (uint8[i] !== sig[i]) throw new Error('Invalid PNG');
            
            const metaChunks = ['tEXt', 'iTXt', 'zTXt', 'eXIf', 'iCCP', 'sRGB', 'gAMA', 'cHRM', 'pHYs', 'sBIT', 'sPLT', 'hIST', 'tIME'];
            const chunks = [];
            let offset = 8;
            
            while (offset < arrayBuffer.byteLength) {
                if (offset + 12 > arrayBuffer.byteLength) break;
                const length = view.getUint32(offset, false);
                const type = String.fromCharCode(uint8[offset+4], uint8[offset+5], uint8[offset+6], uint8[offset+7]);
                const totalSize = 4 + 4 + length + 4;
                
                if (!metaChunks.includes(type)) chunks.push(uint8.slice(offset, offset + totalSize));
                offset += totalSize;
                if (type === 'IEND') break;
            }
            
            const total = 8 + chunks.reduce((s, c) => s + c.length, 0);
            const newBuffer = new ArrayBuffer(total);
            const newUint8 = new Uint8Array(newBuffer);
            newUint8.set(sig, 0);
            let wo = 8;
            for (const chunk of chunks) { newUint8.set(chunk, wo); wo += chunk.length; }
            
            return newBuffer;
        }

        function stripJPEGMetadata(arrayBuffer) {
            const uint8 = new Uint8Array(arrayBuffer);
            if (uint8[0] !== 0xFF || uint8[1] !== 0xD8) throw new Error('Invalid JPEG');
            
            const metaMarkers = new Set();
            for (let i = 0xE1; i <= 0xEF; i++) metaMarkers.add(i);
            metaMarkers.add(0xFE);
            
            const segments = [[...uint8.slice(0, 2)]];
            let offset = 2;
            
            while (offset < arrayBuffer.byteLength) {
                if (uint8[offset] !== 0xFF) { offset++; continue; }
                const marker = uint8[offset + 1];
                
                if (marker === 0xDA) { segments.push([...uint8.slice(offset)]); break; }
                if (marker === 0xD9) { segments.push([...uint8.slice(offset, offset + 2)]); break; }
                if (marker === 0xD8 || (marker >= 0xD0 && marker <= 0xD7) || marker === 0x01) {
                    segments.push([...uint8.slice(offset, offset + 2)]);
                    offset += 2;
                    continue;
                }
                
                if (offset + 4 > arrayBuffer.byteLength) break;
                const length = (uint8[offset + 2] << 8) | uint8[offset + 3];
                const end = offset + 2 + length;
                
                if (!metaMarkers.has(marker)) segments.push([...uint8.slice(offset, end)]);
                offset = end;
            }
            
            const total = segments.reduce((s, seg) => s + seg.length, 0);
            const newBuffer = new ArrayBuffer(total);
            const newUint8 = new Uint8Array(newBuffer);
            let wo = 0;
            for (const seg of segments) { newUint8.set(seg, wo); wo += seg.length; }
            
            return newBuffer;
        }

        // Î©îÏù∏ Ï≤òÎ¶¨
        processBtn.addEventListener('click', async () => {
            if (!selectedFiles.length) return;
            processBtn.disabled = true;
            processBtn.textContent = 'Ï≤òÎ¶¨ Ï§ë...';
            hideStatus();

            try {
                const baseName = baseFilenameInput.value.trim();
                const format = document.querySelector('input[name="format"]:checked').value;
                const quality = parseInt(qualityInput.value) / 100;
                const shouldRemoveMetadata = removeMetadataToggle.checked;

                for (let i = 0; i < selectedFiles.length; i++) {
                    let outputName;
                    if (baseName === '') {
                        outputName = `${i + 1}.${format}`;
                    } else if (selectedFiles.length > 1) {
                        outputName = `${baseName}${i + 1}.${format}`;
                    } else {
                        outputName = `${baseName}.${format}`;
                    }
                    await processAndDownload(selectedFiles[i], outputName, format, quality, shouldRemoveMetadata);
                }

                showStatus(`‚úì ${selectedFiles.length}Í∞ú ÌååÏùº Ï≤òÎ¶¨ ÏôÑÎ£å!`, 'success');
            } catch (err) {
                showStatus(`‚úó Ïò§Î•ò: ${err.message}`, 'error');
            }

            processBtn.disabled = false;
            processBtn.textContent = 'Ï≤òÎ¶¨ Î∞è Îã§Ïö¥Î°úÎìú';
        });

        async function processAndDownload(file, filename, format, quality, removeMetadata) {
            const arrayBuffer = await file.arrayBuffer();
            let cleanedBuffer = arrayBuffer;

            // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ ONÏùº ÎïåÎßå
            if (removeMetadata) {
                if (file.type === 'image/png') cleanedBuffer = stripPNGMetadata(arrayBuffer);
                else if (file.type === 'image/jpeg') cleanedBuffer = stripJPEGMetadata(arrayBuffer);
                else if (file.type === 'image/webp') cleanedBuffer = stripWebPMetadata(arrayBuffer);
            }

            const blob = new Blob([cleanedBuffer], { type: file.type });
            const img = await createImageBitmap(blob);

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ ONÏùº ÎïåÎßå ÏïåÌåå LSBÎèÑ Ïä§ÌÅ¨Îû®Î∏î
            if (removeMetadata) {
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                imageData = scrambleAlphaLSB(imageData);
                ctx.putImageData(imageData, 0, 0);
            }

            const mimeTypes = { png: 'image/png', jpg: 'image/jpeg', webp: 'image/webp' };
            const outputBlob = await new Promise(r => canvas.toBlob(r, mimeTypes[format], quality));

            const link = document.createElement('a');
            link.href = URL.createObjectURL(outputBlob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function showStatus(msg, type) { status.textContent = msg; status.className = `status ${type}`; }
        function hideStatus() { status.className = 'status'; }

        // =====================================================
        // Ïù¥ÎØ∏ÏßÄ Ìé∏ÏßëÍ∏∞
        // =====================================================
        
        const editorOverlay = document.getElementById('editorOverlay');
        const editorCanvas = document.getElementById('editorCanvas');
        const editorClose = document.getElementById('editorClose');
        const editorCancel = document.getElementById('editorCancel');
        const editorSave = document.getElementById('editorSave');
        const toolSize = document.getElementById('toolSize');
        const toolSizeInput = document.getElementById('toolSizeInput');
        const toolColor = document.getElementById('toolColor');
        const colorRow = document.getElementById('colorRow');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const imgPrevBtn = document.getElementById('imgPrevBtn');
        const imgNextBtn = document.getElementById('imgNextBtn');
        const brushCursor = document.getElementById('brushCursor');
        const saveModal = document.getElementById('saveModal');
        const saveModalDiscard = document.getElementById('saveModalDiscard');
        const saveModalCancel = document.getElementById('saveModalCancel');
        const saveModalSave = document.getElementById('saveModalSave');
        const editorCtx = editorCanvas.getContext('2d');
        
        let editingIndex = null;
        let originalImage = null;
        let currentTool = 'brush-color'; // brush-color, brush-mosaic, rect
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let startX = 0, startY = 0;
        let historyStack = [];
        let redoStack = [];
        let tempCanvas = null;
        let hasChanges = false; // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∞êÏßÄ
        let pendingAction = null; // Ï†ÄÏû• ÌôïÏù∏ ÌõÑ Ïã§ÌñâÌï† Ïï°ÏÖò
        
        // Î∏åÎü¨Ïãú Ïª§ÏÑú ÏóÖÎç∞Ïù¥Ìä∏
        function updateBrushCursor(e) {
            if (currentTool === 'rect') {
                brushCursor.classList.remove('active');
                return;
            }
            
            const size = parseInt(toolSize.value);
            brushCursor.style.width = size + 'px';
            brushCursor.style.height = size + 'px';
            brushCursor.style.left = e.clientX + 'px';
            brushCursor.style.top = e.clientY + 'px';
            
            brushCursor.classList.toggle('mosaic', currentTool === 'brush-mosaic');
        }
        
        // Ï∫îÎ≤ÑÏä§ ÏòÅÏó≠ÏóêÏÑú Î∏åÎü¨Ïãú Ïª§ÏÑú ÌëúÏãú
        const canvasArea = document.querySelector('.editor-canvas-area');
        canvasArea.addEventListener('mouseenter', (e) => {
            if (currentTool !== 'rect') {
                brushCursor.classList.add('active');
                updateBrushCursor(e);
            }
        });
        canvasArea.addEventListener('mousemove', (e) => {
            updateBrushCursor(e);
        });
        canvasArea.addEventListener('mouseleave', () => {
            brushCursor.classList.remove('active');
        });
        
        // ÌÅ¨Í∏∞ Ïä¨ÎùºÏù¥Îçî <-> ÏûÖÎ†• ÎèôÍ∏∞Ìôî
        toolSize.addEventListener('input', () => {
            toolSizeInput.value = toolSize.value;
        });
        toolSizeInput.addEventListener('input', () => {
            let val = parseInt(toolSizeInput.value) || 5;
            val = Math.max(5, Math.min(100, val));
            toolSize.value = val;
        });
        toolSizeInput.addEventListener('blur', () => {
            let val = parseInt(toolSizeInput.value) || 30;
            val = Math.max(5, Math.min(100, val));
            toolSizeInput.value = val;
            toolSize.value = val;
        });
        
        // ÎèÑÍµ¨ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                
                // Î™®ÏûêÏù¥ÌÅ¨ Î∏åÎü¨ÏãúÏùº ÎïåÎäî ÏÉâÏÉÅ ÏÑ†ÌÉù Ïà®Í∏∞Í∏∞
                colorRow.style.display = currentTool === 'brush-mosaic' ? 'none' : 'flex';
                
                // ÏÇ¨Í∞ÅÌòï ÎèÑÍµ¨Î©¥ Î∏åÎü¨Ïãú Ïª§ÏÑú Ïà®Í∏∞Í∏∞
                if (currentTool === 'rect') {
                    brushCursor.classList.remove('active');
                }
            });
        });
        
        // ÎêòÎèåÎ¶¨Í∏∞/Îã§ÏãúÌïòÍ∏∞ Î≤ÑÌäº
        undoBtn.addEventListener('click', undoEdit);
        redoBtn.addEventListener('click', redoEdit);
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyStack.length <= 1;
            redoBtn.disabled = redoStack.length === 0;
        }
        
        // Ïù¥ÎØ∏ÏßÄ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        function updateNavButtons() {
            imgPrevBtn.disabled = editingIndex <= 0;
            imgNextBtn.disabled = editingIndex >= selectedFiles.length - 1;
        }
        
        // Ïù¥Ï†Ñ/Îã§Ïùå Ïù¥ÎØ∏ÏßÄÎ°ú Ïù¥Îèô (Ï†ÄÏû• ÌôïÏù∏)
        imgPrevBtn.addEventListener('click', () => {
            if (editingIndex > 0) {
                tryNavigate(editingIndex - 1);
            }
        });
        
        imgNextBtn.addEventListener('click', () => {
            if (editingIndex < selectedFiles.length - 1) {
                tryNavigate(editingIndex + 1);
            }
        });
        
        // Ï†ÄÏû• ÌôïÏù∏ ÌõÑ Ïù¥Îèô
        function tryNavigate(newIndex) {
            if (hasChanges) {
                pendingAction = { type: 'navigate', index: newIndex };
                saveModal.classList.add('active');
            } else {
                switchToImage(newIndex);
            }
        }
        
        // Ï†ÄÏû• ÌôïÏù∏ ÌõÑ Îã´Í∏∞
        function tryClose() {
            if (hasChanges) {
                pendingAction = { type: 'close' };
                saveModal.classList.add('active');
            } else {
                closeEditor();
            }
        }
        
        // Ï†ÄÏû• Î™®Îã¨ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        saveModalDiscard.addEventListener('click', async () => {
            saveModal.classList.remove('active');
            if (pendingAction) {
                if (pendingAction.type === 'navigate') {
                    switchToImage(pendingAction.index);
                } else if (pendingAction.type === 'close') {
                    closeEditor();
                }
                pendingAction = null;
            }
        });
        
        saveModalCancel.addEventListener('click', () => {
            saveModal.classList.remove('active');
            pendingAction = null;
        });
        
        saveModalSave.addEventListener('click', async () => {
            saveModal.classList.remove('active');
            await applyEdit();
            
            if (pendingAction) {
                if (pendingAction.type === 'navigate') {
                    switchToImage(pendingAction.index);
                } else if (pendingAction.type === 'close') {
                    closeEditor();
                }
                pendingAction = null;
            }
        });
        
        // Ïù¥ÎØ∏ÏßÄ Ï†ÑÌôò
        function switchToImage(newIndex) {
            editingIndex = newIndex;
            historyStack = [];
            redoStack = [];
            hasChanges = false;
            
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                
                const maxSize = 800;
                let w = img.width;
                let h = img.height;
                
                if (w > maxSize || h > maxSize) {
                    if (w > h) {
                        h = (h / w) * maxSize;
                        w = maxSize;
                    } else {
                        w = (w / h) * maxSize;
                        h = maxSize;
                    }
                }
                
                editorCanvas.width = w;
                editorCanvas.height = h;
                editorCanvas.dataset.scale = w / img.width;
                
                editorCtx.drawImage(img, 0, 0, w, h);
                saveHistory(true);
                updateNavButtons();
            };
            img.src = filePreviews[newIndex];
        }
        
        // Ìé∏ÏßëÍ∏∞ Ïó¥Í∏∞
        function openEditor(index) {
            editingIndex = index;
            historyStack = [];
            redoStack = [];
            hasChanges = false;
            
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                
                // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï (ÏµúÎåÄ 800px)
                const maxSize = 800;
                let w = img.width;
                let h = img.height;
                
                if (w > maxSize || h > maxSize) {
                    if (w > h) {
                        h = (h / w) * maxSize;
                        w = maxSize;
                    } else {
                        w = (w / h) * maxSize;
                        h = maxSize;
                    }
                }
                
                editorCanvas.width = w;
                editorCanvas.height = h;
                editorCanvas.dataset.scale = w / img.width;
                
                editorCtx.drawImage(img, 0, 0, w, h);
                saveHistory(true); // Ï¥àÍ∏∞ ÏÉÅÌÉúÎäî Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏïÑÎãò
                updateNavButtons();
                
                editorOverlay.classList.add('active');
            };
            img.src = filePreviews[index];
        }
        
        // ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•
        function saveHistory(isInitial = false) {
            if (historyStack.length > 30) historyStack.shift();
            historyStack.push(editorCanvas.toDataURL());
            redoStack = []; // ÏÉà ÏûëÏóÖÌïòÎ©¥ redo Ïä§ÌÉù Ï¥àÍ∏∞Ìôî
            updateUndoRedoButtons();
            
            // Ï¥àÍ∏∞ ÏÉÅÌÉúÍ∞Ä ÏïÑÎãàÎ©¥ Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏûàÏùå
            if (!isInitial) {
                hasChanges = true;
            }
        }
        
        // ÎêòÎèåÎ¶¨Í∏∞
        function undoEdit() {
            if (historyStack.length <= 1) return;
            const current = historyStack.pop();
            redoStack.push(current);
            
            const img = new Image();
            img.onload = () => {
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                editorCtx.drawImage(img, 0, 0);
                updateUndoRedoButtons();
            };
            img.src = historyStack[historyStack.length - 1];
        }
        
        // Îã§ÏãúÌïòÍ∏∞
        function redoEdit() {
            if (redoStack.length === 0) return;
            const redo = redoStack.pop();
            historyStack.push(redo);
            
            const img = new Image();
            img.onload = () => {
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                editorCtx.drawImage(img, 0, 0);
                updateUndoRedoButtons();
            };
            img.src = redo;
        }
        
        // Î™®ÏûêÏù¥ÌÅ¨ Í∑∏Î¶¨Í∏∞ (ÏõêÌòï ÏòÅÏó≠)
        function drawMosaic(x, y, size) {
            const blockSize = Math.max(8, Math.floor(size / 3));
            const half = size / 2;
            
            const sx = Math.max(0, Math.floor(x - half));
            const sy = Math.max(0, Math.floor(y - half));
            const ex = Math.min(editorCanvas.width, Math.ceil(x + half));
            const ey = Math.min(editorCanvas.height, Math.ceil(y + half));
            
            const imageData = editorCtx.getImageData(sx, sy, ex - sx, ey - sy);
            const data = imageData.data;
            
            for (let by = 0; by < ey - sy; by += blockSize) {
                for (let bx = 0; bx < ex - sx; bx += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    for (let py = by; py < Math.min(by + blockSize, ey - sy); py++) {
                        for (let px = bx; px < Math.min(bx + blockSize, ex - sx); px++) {
                            const i = (py * (ex - sx) + px) * 4;
                            r += data[i];
                            g += data[i + 1];
                            b += data[i + 2];
                            count++;
                        }
                    }
                    
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);
                    
                    for (let py = by; py < Math.min(by + blockSize, ey - sy); py++) {
                        for (let px = bx; px < Math.min(bx + blockSize, ex - sx); px++) {
                            const i = (py * (ex - sx) + px) * 4;
                            data[i] = r;
                            data[i + 1] = g;
                            data[i + 2] = b;
                        }
                    }
                }
            }
            
            editorCtx.putImageData(imageData, sx, sy);
        }
        
        // Î∏åÎü¨Ïãú Í∑∏Î¶¨Í∏∞
        function drawBrush(x, y, size, color) {
            editorCtx.beginPath();
            editorCtx.arc(x, y, size / 2, 0, Math.PI * 2);
            editorCtx.fillStyle = color;
            editorCtx.fill();
        }
        
        // Î∏åÎü¨Ïãú ÏÑ† Í∑∏Î¶¨Í∏∞
        function drawBrushLine(x1, y1, x2, y2, size, color) {
            editorCtx.beginPath();
            editorCtx.moveTo(x1, y1);
            editorCtx.lineTo(x2, y2);
            editorCtx.strokeStyle = color;
            editorCtx.lineWidth = size;
            editorCtx.lineCap = 'round';
            editorCtx.stroke();
        }
        
        // ÏÇ¨Í∞ÅÌòï Î™®ÏûêÏù¥ÌÅ¨ Í∑∏Î¶¨Í∏∞
        function drawRectMosaic(x1, y1, x2, y2) {
            const x = Math.min(x1, x2);
            const y = Math.min(y1, y2);
            const w = Math.abs(x2 - x1);
            const h = Math.abs(y2 - y1);
            
            if (w < 2 || h < 2) return;
            
            const blockSize = Math.max(8, Math.floor(parseInt(toolSize.value) / 3));
            const imageData = editorCtx.getImageData(x, y, w, h);
            const data = imageData.data;
            
            for (let by = 0; by < h; by += blockSize) {
                for (let bx = 0; bx < w; bx += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    for (let py = by; py < Math.min(by + blockSize, h); py++) {
                        for (let px = bx; px < Math.min(bx + blockSize, w); px++) {
                            const i = (py * w + px) * 4;
                            r += data[i];
                            g += data[i + 1];
                            b += data[i + 2];
                            count++;
                        }
                    }
                    
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);
                    
                    for (let py = by; py < Math.min(by + blockSize, h); py++) {
                        for (let px = bx; px < Math.min(bx + blockSize, w); px++) {
                            const i = (py * w + px) * 4;
                            data[i] = r;
                            data[i + 1] = g;
                            data[i + 2] = b;
                        }
                    }
                }
            }
            
            editorCtx.putImageData(imageData, x, y);
        }
        
        // Ï∫îÎ≤ÑÏä§ Ïù¥Î≤§Ìä∏
        editorCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            lastX = (e.clientX - rect.left) * scaleX;
            lastY = (e.clientY - rect.top) * scaleY;
            startX = lastX;
            startY = lastY;
            
            if (currentTool === 'rect') {
                // ÏûÑÏãú Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
                tempCanvas = document.createElement('canvas');
                tempCanvas.width = editorCanvas.width;
                tempCanvas.height = editorCanvas.height;
                tempCanvas.getContext('2d').drawImage(editorCanvas, 0, 0);
            } else if (currentTool === 'brush-mosaic') {
                drawMosaic(lastX, lastY, parseInt(toolSize.value));
            } else if (currentTool === 'brush-color') {
                drawBrush(lastX, lastY, parseInt(toolSize.value), toolColor.value);
            }
        });
        
        editorCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            if (currentTool === 'brush-mosaic') {
                drawMosaic(x, y, parseInt(toolSize.value));
            } else if (currentTool === 'brush-color') {
                drawBrushLine(lastX, lastY, x, y, parseInt(toolSize.value), toolColor.value);
            } else if (currentTool === 'rect' && tempCanvas) {
                // ÏûÑÏãú Ï∫îÎ≤ÑÏä§ÏóêÏÑú Î≥µÏõê ÌõÑ ÏÇ¨Í∞ÅÌòï ÎØ∏Î¶¨Î≥¥Í∏∞
                editorCtx.drawImage(tempCanvas, 0, 0);
                editorCtx.strokeStyle = toolColor.value;
                editorCtx.lineWidth = 2;
                editorCtx.setLineDash([5, 5]);
                editorCtx.strokeRect(
                    Math.min(startX, x), Math.min(startY, y),
                    Math.abs(x - startX), Math.abs(y - startY)
                );
                editorCtx.setLineDash([]);
            }
            
            lastX = x;
            lastY = y;
        });
        
        editorCanvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (currentTool === 'rect' && tempCanvas) {
                const rect = editorCanvas.getBoundingClientRect();
                const scaleX = editorCanvas.width / rect.width;
                const scaleY = editorCanvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                editorCtx.drawImage(tempCanvas, 0, 0);
                
                // Îã®ÏÉâ ÏÇ¨Í∞ÅÌòï
                const rx = Math.min(startX, x);
                const ry = Math.min(startY, y);
                const rw = Math.abs(x - startX);
                const rh = Math.abs(y - startY);
                editorCtx.fillStyle = toolColor.value;
                editorCtx.fillRect(rx, ry, rw, rh);
                
                tempCanvas = null;
            }
            
            saveHistory();
        });
        
        editorCanvas.addEventListener('mouseleave', () => {
            if (isDrawing && currentTool !== 'rect') {
                isDrawing = false;
                saveHistory();
            }
        });
        
        // Ìé∏ÏßëÍ∏∞ Îã´Í∏∞ Î≤ÑÌäº (Ï†ÄÏû• ÌôïÏù∏)
        editorClose.addEventListener('click', tryClose);
        editorCancel.addEventListener('click', tryClose);
        
        function closeEditor() {
            editorOverlay.classList.remove('active');
            brushCursor.classList.remove('active');
            editingIndex = null;
            historyStack = [];
            redoStack = [];
            hasChanges = false;
        }
        
        // Ìé∏Ïßë Ï†ÅÏö© Ìï®Ïàò (Ïû¨ÏÇ¨Ïö©)
        async function applyEdit() {
            if (editingIndex === null) return;
            
            // ÏõêÎ≥∏ ÌÅ¨Í∏∞Î°ú Îã§Ïãú Í∑∏Î¶¨Í∏∞
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = originalImage.width;
            finalCanvas.height = originalImage.height;
            const finalCtx = finalCanvas.getContext('2d');
            
            // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Í∑∏Î¶∞ ÌõÑ Ìé∏ÏßëÎêú ÎÇ¥Ïö©ÏùÑ Ïä§ÏºÄÏùºÏóÖÌï¥ÏÑú ÎçÆÏñ¥ÏîåÏö∞Í∏∞
            finalCtx.drawImage(originalImage, 0, 0);
            finalCtx.drawImage(editorCanvas, 0, 0, originalImage.width, originalImage.height);
            
            // BlobÏúºÎ°ú Î≥ÄÌôò
            const blob = await new Promise(r => finalCanvas.toBlob(r, 'image/png'));
            const file = new File([blob], selectedFiles[editingIndex].name, { type: 'image/png' });
            
            // ÌååÏùº ÍµêÏ≤¥
            URL.revokeObjectURL(filePreviews[editingIndex]);
            selectedFiles[editingIndex] = file;
            filePreviews[editingIndex] = URL.createObjectURL(blob);
            
            hasChanges = false;
            updateImageGrid();
        }
        
        // Ìé∏Ïßë Ï†ÅÏö© Î≤ÑÌäº
        editorSave.addEventListener('click', async () => {
            await applyEdit();
            closeEditor();
        });
        
        // ESCÎ°ú Îã´Í∏∞, Ctrl+Z ÎêòÎèåÎ¶¨Í∏∞, Ctrl+Y Îã§ÏãúÌïòÍ∏∞, Ï¢åÏö∞ ÌôîÏÇ¥Ìëú Ïù¥ÎØ∏ÏßÄ Ïù¥Îèô
        document.addEventListener('keydown', (e) => {
            if (!editorOverlay.classList.contains('active')) return;
            if (saveModal.classList.contains('active')) return; // Î™®Îã¨ Ïó¥Î†§ÏûàÏúºÎ©¥ Î¨¥Ïãú
            
            if (e.key === 'Escape') {
                tryClose();
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undoEdit();
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                redoEdit();
            }
            
            // Ï¢åÏö∞ ÌôîÏÇ¥ÌëúÎ°ú Ïù¥ÎØ∏ÏßÄ Ïù¥Îèô
            if (e.key === 'ArrowLeft' && editingIndex > 0) {
                e.preventDefault();
                tryNavigate(editingIndex - 1);
            }
            
            if (e.key === 'ArrowRight' && editingIndex < selectedFiles.length - 1) {
                e.preventDefault();
                tryNavigate(editingIndex + 1);
            }
        });
    </script>
</body>
</html>
